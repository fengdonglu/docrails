h2. Active Record基础

本指南是Active Record的介绍。我们希望你通过本指南可以学习到：

* 什么是ORM和Active Record，它们在Rails的作用
* Active Record在MVC模式中的作用
* 如何使用Active Record模型操作关系型数据库中存储的数据
* Active Record模式名称转换
* 数据库迁移的概念、校验和回调

endprologue.

h3. 什么是ActiveRecord?

Active Record是"MVC"中的M： getting_started.html#the-mvc-architecture - the model - which is the layer of the system responsible for representing business data and logic. Active Record facilitates the creation and use of business objects whose data requires persistent storage to a database. It is an implementation of the Active Record pattern which itself is a description of an Object Relational Mapping system.

h4. The Active Record模式

Martin Fowler在他的书 _Patterns of Enterprise Application Architecture_ 中描述了Active Record. 在ActiveRecord中，对象携带着所有的非易失的数据和操作数据的行为。Active Record takes the opinion that ensuring data access logic is part of the object will educate users of that object on how to write to and read from the database.

h4. Object Relational Mapping

Object-Relational Mapping，通常缩写成ORM, 是用来将应用程序中丰富的对象连接至关系型数据库管理库中的表的技术。使用ORM，可以在不写SQL语句，使用很少的数据库访问代码的情况下，在数据库中轻易地存储和检索应用程序中对象的属性和关系。

h4. 作为ORM框架的ActiveRecord

ActiveRecord给了我们一些机制, 其中最重要的功能是：

* Represent models和其中的数据
* Represent associations between these models
* Represent inheritance hierarchies through related models
* 在保存至数据库前校验模型
* 以面向对象的风格实现数据库操作

h3. Convention over Configuration in Active Record

When writing applications using other programming languages or frameworks, it may be necessary to write a lot of configuration code. This is particularly true for ORM frameworks in general. However, if you follow the conventions adopted by Rails, you'll need to write very little configuration (in some case no configuration at all) when creating Active Record models. The idea is that if you configure your applications in the very same way most of the times then this should be the default way. In this cases, explicit configuration would be needed only in those cases where you can't follow the conventions for any reason.

h4. 名称转换

默认地, Active Record使用一些名称转换to find out how the mapping between models and database tables should be created. Rails will pluralize your class names to find the respective database table. So, for a class +Book+, you should have a database table called *books*. The Rails pluralization mechanisms are very powerful, being capable to pluralize (and singularize) both regular and irregular words. When using class names composed of two or more words, the model class name should follow the Ruby conventions, using the camelCase form, while the table name must contain the words separated by underscores. Examples:

* 数据库表 - Plural with underscores separating words (e.g., book_clubs)
* 模型类 - Singular with the first letter of each word capitalized (e.g., BookClub)

|_.模型 / 类 |_.表 / 模式 |
|Post          |posts|
|LineItem      |line_items|
|Deer          |deer|
|Mouse         |mice|
|Person        |people|


h4. 模式转换

Active Record使用名称转换for the columns in database tables，基于这些列的意图。

* *外键* - These fields should be named following the pattern table_id (e.g., item_id, order_id). These are the fields that Active Record will look for when you create associations between your models.
* *主键* - 默认情况下，ActiveRecord会使用名为"id"的整数字段作为表的主键。当使用"Rails Migrations":migrations.html to create your tables, this column will be automatically created.

另外还有一些可选的列名可以用于描述ActiveRecord实例的特性：

* *created_at* - 自动设为记录的创建日期和时间
* *created_on* - 自动设为记录的创建日期
* *updated_at* - 自动设为记录的更新日期和时间
* *updated_on* - 自动设为记录的更新日期
* *lock_version* - Adds "optimistic locking":http://api.rubyonrails.org/classes/ActiveRecord/Locking.html to a model.
* *type* - Specifies that the model uses "Single Table Inheritance":http://api.rubyonrails.org/classes/ActiveRecord/Base.html
* *(table_name)_count* - Used to cache the number of belonging objects on associations. 例如, a +comments_count+ column in a +Post+ class that has many instances of +Comment+ will cache the number of existent comments for each post.

NOTE: While these column names are optional they are in fact reserved by Active Record. Steer clear of reserved keywords unless you want the extra functionality. For example, "type" is a reserved keyword used to designate a table using Single Table Inheritance. 如果你不使用STI, try an analogous keyword like "context", that may still accurately describe the data you are modeling.

h3. 创建ActiveRecord模型

很容易创建ActiveRecord模型。你要做的只是继承 +ActiveRecord::Base+ 类，你可以这样：

<ruby>
class Product < ActiveRecord::Base; end
</ruby>

这样就创建了 +Product+ 模型，映射到数据库中名为 *products* 的表。By doing this you'll also have the ability to map the columns of each row in that table with the attributes of the instances of your model. So, suppose that the *products* table was created using an SQL sentence like:

<sql>
CREATE TABLE products (
   id int(11) NOT NULL auto_increment,
   name varchar(255),
   PRIMARY KEY  (id)
);
</sql>

按以上的表模式，你可以象下面那样写代码：

<ruby>
p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"
</ruby>

h3. 重载名称转换

What if you need to follow a different naming convention or need to use your Rails application with a legacy database? No problem, you can easily override the default conventions.

你可以使用 +ActiveRecord::Base.set_table_name+ 方法指定要使用的表名：

<ruby>
class Product < ActiveRecord::Base
  set_table_name "PRODUCT"
end
</ruby>

If you do so, 你必须手工地定义类名that is hosting the fixtures (class_name.yml) using the +set_fixture_class+ method in your test definition:

<ruby>
class FunnyJoke < ActiveSupport::TestCase
  set_fixture_class :funny_jokes => 'Joke'
  fixtures :funny_jokes
  ...
end
</ruby>

It's also possible to override the column that should be used as the table's primary key using the +ActiveRecord::Base.set_primary_key+ method:

<ruby>
class Product < ActiveRecord::Base
  set_primary_key "product_id"
end
</ruby>

h3. 读写数据

CRUD is an acronym for the four verbs we use to operate on data: *C*reate, *R*ead, *U*pdate and *D*elete. Active Record automatically creates methods to allow an application to read and manipulate data stored within its tables.

h4. 创建

Active Record objects can be created from a hash, a block or have its attributes manually set after creation. The _new_ method will return a new object while _create_ will return the object and save it to the database.

例如, given a model +User+ with attributes of +name+ and +occupation+, the _create_ method call will create and save a new record into the database:

<ruby>
  user = User.create(:name => "David", :occupation => "Code Artist")
</ruby>

使用 _new_ 方法，对象可以不用保存而先被创建出来：

<ruby>
  user = User.new
  user.name = "David"
  user.occupation = "Code Artist"
</ruby>

A call to _user.save_ will commit the record to the database.

最后， passing a block to either create or new will return a new User object:

<ruby>
  user = User.new do |u|
    u.name = "David"
    u.occupation = "Code Artist"
  end
</ruby>

h4. 读取

ActiveRecord提供了丰富的API在数据库中访问数据。以下是由Active Record提供的不同的数据库访问方法的一些例子。

<ruby>
  # 返回所有的记录
  users = User.all
</ruby>

<ruby>
  # 返回首条记录
  user = User.first
</ruby>

<ruby>
  # 返回首个名叫David的用户
  david = User.find_by_name('David')
</ruby>

<ruby>
  # find all users named David who are Code Artists and sort by created_at in reverse chronological order
  users = User.where(:name => 'David', :occupation => 'Code Artist').order('created_at DESC')
</ruby>

You can learn more about querying an Active Record model in the "Active Record Query Interface":"active_record_querying.html" guide.

h4. 修改

ActiveRecord对象被检索后， 它的属性据可以被修改，并回存至数据库。

<ruby>
  user = User.find_by_name('David')
  user.name = 'Dave'
  user.save
</ruby>

h4. 删除

Likewise, once retrieved an Active Record object can be destroyed which removes it from the database.

<ruby>
  user = User.find_by_name('David')
  user.destroy
</ruby>

h3. 校验

Active Record允许你在将模型写入数据库前进行状态校验。There are several methods that you can use to check your models and validate that an attribute value is not empty, is unique and not already in the database, follows a specific format and many more. You can learn more about validations in the "Active Record Validations and Callbacks guide":active_record_validations_callbacks.html#validations-overview.

h3. 回调

ActiveRecord回调允许你to attach code to certain events in the life-cycle of your models. This enables you to add behavior to your models by transparently executing code when those events occur, like when you create a new record, update it, destroy it and so on. You can learn more about callbacks in the "Active Record Validations and Callbacks guide":active_record_validations_callbacks.html#callbacks-overview.

h3. 迁移

Rails provides a domain-specific language for managing a database schema called migrations. Migrations are stored in files which are executed against any database that Active Record support using rake. Rails keeps track of which files have been committed to the database and provides rollback features. You can learn more about migrations in the "Active Record Migrations guide":migrations.html
