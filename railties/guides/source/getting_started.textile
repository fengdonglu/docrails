h2. Rails 初上手指南

这份文件涵盖了如何上手使用Ruby on Rails。阅读之后您应该可以熟悉：

* 安装Rails，建立一个新的Rails 应用程式，并连结到资料库
* Rails 的架构
* MVC (Model, View Controller)基本原理以及RESTful设计
* 如何快速产生可以运作的Rails 应用程式

endprologue.

WARNING. 这份文件基于Rails 3.0。某些程式码无法运行于旧版Rails。

h3. 前提条件

这份指南的目标是为了帮助初学者从头开始学习Rails 应用程式，而不需要有任何Rails 经验。不过要能够读的懂，还是需要一些前提：

* "Ruby 语言":http://www.ruby-lang.org/en/downloads 版本1.8.7或1.9.2之后

TIP: Ruby 1.8.7 p248和p249已知有marshaling臭虫会搞烂Rails 3.0。而Ruby Enterprise Edition需要1.8.7-2010.02之后的版本。1.9.1也不适用有segfaults，所以如果你要用1.9系列请从1.9.2开始。

* "RubyGems":http://rubyforge.org/frs/?group_id=126 Ruby的 ​​套件管理系统
  ** 如果你希望深入学习 RubyGems ，请查阅 "RubyGems 用户指南":http://docs.rubygems.org/read/book/1
* 一个可工作的 "SQLite3 数据库":http://www.sqlite.org

Rails 是一套使用Ruby 的Web 框架。如果您对Ruby 一无所知就一头栽进Rails，您的学习曲线会非常陡峭。以下是一些网路上的免费Ruby 学习资源：

* "Mr. Neighborly's Humble Little Ruby Book":http://www.humblelittlerubybook.com
* "Programming Ruby":http://www.ruby-doc.org/docs/ProgrammingRuby/
* "Why's (Poignant) Guide to Ruby":http://mislav.uniqpath.com/poignant-guide/

另外，这份指南的示例在 github:https://github.com/rails/rails 的代码仓库中可以找到，路径在 rails/railties/guides/code/getting_started 。

h3. 什么是Rails?

Rails 是个使用Ruby 程式语言开发的网站开发框架。它的设计目标是：只要开发者熟悉它的惯例，它就可以让网站开发变的非常容易。而相对于其他程式语言和框架，Rails 可以让你用更少的程式代码达成更多的功能。经验丰富的 Rails 开发者也表示它让网站开发更有趣了。

Rails 也是个很有主见(opinionated)的软体。意思是说它假定事情有"最佳解"，而且它也被设计成鼓励那么做– 而不鼓励其他作法。如果你学会所谓的“The Rails Way” 的话，你的生产力非常可能获得极大的增长。但如果你硬套用其他语言的习惯或模式来使用Rails，你可能会有不愉快的使用经验。

Rails 的哲学包括以下指导原则：

* DRY – “不要重复你自己(Don't Repeat Yourself)” –建议只写一次代码，撰写出重复的程式码就是做错事。
* 惯例胜于设计(Convention Over Configuration) – Rails 会假设什么是你要做的事情跟如何去做，而不是要求你设定每一个细节到设定档中。
* REST是Web应用程式的最佳模式–使用Resources和标准的HTTP verbs(动词)来组织你的应用程式是最快的方式。

h4. MVC架构

Rails 的核心是Model, View 和Controller 的架构，通常称作MVC。MVC 的好处包括：

* 从使用者介面中把商业逻辑隔离出来
* 更容易使程式保持DRY
* 容易维护，让不同的程式码干净地放在属于它的地方

h5. Models

Model 代表了应用程式的资料和操作资料的逻辑。在Rails 中，Models 主要的功能是负责操作资料库资料表。在大多数的情况，一个资料表就对应了一个Model。你的应用程式商业逻辑也会放在Models 中。

h5. Views

Views代表了应用程式的使用者介面。在Rails中，Views通常就是有内嵌Ruby程式(可以操纵如何显示资料)的HTML档案。Views负责提供资料给浏览器或或其他发送HTTP请求的软体。

h5. Controllers

Controllers是Models和Views之间的胶水。在Rails中，Controllers负责处理来自浏览器的HTTP请求，与模型交换数据，然后将资料传进Views中显示出来。
Controllers provide the "glue" between models and views. In Rails, controllers
are responsible for processing the incoming requests from the web browser,
interrogating the models for data, and passing that data on to the views for
presentation.

h4. Rails 的元件

Rails 自带了了很多 individual 的组件。每个组件 are briefly explained below.  如果你是 Rails 新手，你可以看看这节，但是不拘泥于每个组件的细节， 因为后面会详细地解释。 For instance, we will bring up Rack applications, but you don't need to know anything about them to continue with this guide.

* Action Pack
  ** Action Controller
  ** Action Dispatch
  ** Action View
* Action Mailer
* Active Model
* Active Record
* Active Resource
* Active Support
* Railties

h5. Action Pack

Action Pack是个包含了Action Controller、Action View和Action Dispatch的gem。也就是“ MVC ”中的“VC”部分。

h6. Action Controller

Action Controller是Rails应用程式中，管理Controllers的元件。Action Controller框架处理传给Rails的HTTP请求，提取出参数，然后分派给所属的Action。Action Controller还提供了session管理、模板渲染和重定向管理功能。

h6. Action View

Action View负责Rails应用程式中的Views。它预设可以产生HTML或XML输出。Action View负责模板渲染，包括嵌套(nesting)或局部(partial)样板，甚至也内建支援一些Ajax。View templates are covered in more detail in another guide called "Layouts and Rendering":layouts_and_rendering.html.

h6. Action Dispatch

Action Dispatch处理HTTP请求的路由(routing)，它把HTTP请求发派(dispatch)到它该去的地方，可能是你的应用程式或者其他Rack程式。Rack applications are
a more advanced topic and are covered in a separate guide called "Rails on Rack":rails_on_rack.html.

h5. Action Mailer

Action Mailer 是个建构 E-mail 服务的框架。你可以使用Action Mailer 来接收和处理邮件，或是使用样板来寄出纯文字或复杂的multipart 邮件。

h5. Active Model

Active Model在Action Pack gem和ORM gem (例如Active Record)之间定义了一组介面。Active Model允许Rails可以依你的需求把Active Record换成其他ORM框架。

h5. Active Record

Active Record是Rails应用程式中的Models基础。它提供了数据库透明，基本的CRUD功能、高级查询能力以及可以跟其他Models关联的本事。

h5. Active Resource

Active Resource提供了与其他商业物件和RESTful网络服务的连结框架。它实现了一种可以对应以Web为基础的Resources成为本地端支援CRUD的物件。

h5. Active Support

Active Support 是Rails 里的工具函式库，它也扩充了一些Ruby 标准函式库。除了被用在Rails 核心程式中，你也可以在你的程式中使用。

h5. Railties

Railties 是Rails 的核心程式码，用来把以上各种的框架函式库以及Plugin 全部组合在一起。

h4. REST

REST是表象化状态转变（Representational State Transfer）的缩写，是RESTful架构的基础概念。它被认为出自于Roy Fielding的博士论文 "Architectural Styles and the Design of Network-based Software Architectures":http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm 。当你阅读这篇论文的时候，REST被Rails浓缩成两个主要定理：

* 使用Resource 来当做识别资源，也就是使用URLs 来代表Resources
* Transferring representations of the state of that resource between system components.

例如，对Rails应用程式来说，这样的HTTP请求：

<tt>DELETE /photos/17</tt>

被解读为指向photo resource 的ID 17，并带着一个动作– 删除这个resource。REST 对Web 应用程式来说是一种天生的设计风格，而Rails 帮你把这个概念包装实作出来，并且免于众多繁杂RESTful 理论及浏览器怪癖之苦。

如果你想知道更多关于REST架构风格，以下资源比起Fielding的论文更容易亲近：

* "A Brief Introduction to REST":http://www.infoq.com/articles/rest-introduction by Stefan Tilkov
* "An Introduction to REST":http://bitworking.org/news/373/An-Introduction-to-REST (video tutorial) by Joe Gregorio
* "Representational State Transfer":http://en.wikipedia.org/wiki/Representational_State_Transfer article in Wikipedia
* "How to GET a Cup of Coffee":http://www.infoq.com/articles/webber-rest-workflow by Jim Webber, Savas Parastatidis &
Ian Robinson

h3. 创建新的 Rails 专案

接下来的范例，你将建立一个叫做<tt>blog</tt>的Rails专案，是个非常简单的部落格系统。在你开始建构这个应用之前，需要确认你的Rails已经安装妥当。

TIP: 以下的示例使用了 # 和 $ 作为终端提示符。如果你使用 Windows ，你的提示符看起来可能会象这样： c:\source_code>

h4. 安装Rails

大多数的情况下，通过Rubygems安装是最简单的方式：

<shell>
Usually run this as the root user:
# gem install rails
</shell>

TIP. 如果你使用 Windows ，你可以使用 "Rails Installer":http://railsinstaller.org 进行快速安装。

h4. 建立部落格应用程式

本指南的最佳学习方式就是紧跟着接下来的每个步骤。没有任何步骤或程式会被省略，所以你可以一步步跟着。如果你需要下载完整的程式，可以从 "这里":https://github.com/mikel/getting-started-code 下载。

开始，首先打开终端窗口，然后找个目录适合放你的程式，接着输入：

<shell>
$ rails new blog
</shell>

这会在 blog 目录下建立一个叫做 Blog 的Rails 应用程式。

TIP: 你可以透过 <tt>rails new -h</tt> 命令看到所有可用的选项。

完成之后，进到这个目录下继续：

<shell>
$ cd blog
</shell>

总之，Rails会建立一个工作目录叫做<tt>blog</tt>。请打开这个目录看看它的内容。本教程的大部分工作都会<tt>app</tt>目录下进行，这里来简单走访一下各个目录的功能吧：

|_.File/Folder|_.Purpose|
|Gemfile|This file allows you to specify what gem dependencies are needed for your Rails application. See section on Bundler, below.|
|README|This is a brief instruction manual for your application. You should edit this file to tell others what your application does, how to set it up, and so on.|
|Rakefile|This file locates and loads tasks that can be run from the command line. The task definitions are defined throughout the components of Rails. Rather than changing Rakefile, you should add your own tasks by adding files to the lib/tasks directory of your application.|
|app/|Contains the controllers, models, views and assets for your application. You'll focus on this folder for the remainder of this guide.|
|config/|Configure your application's runtime rules, routes, database, and more.|
|config.ru|Rack configuration for Rack based servers used to start the application.|
|db/|Shows your current database schema, as well as the database migrations. You'll learn about migrations shortly.|
|doc/|In-depth documentation for your application.|
|lib/|Extended modules for your application (not covered in this guide).|
|log/|Application log files.|
|public/|The only folder seen to the world as-is. Contains the static files and compiled assets.|
|script/|Contains the rails script that starts your app and can contain other scripts you use to deploy or run your application.|
|test/|Unit tests, fixtures, and other test apparatus. These are covered in "Testing Rails Applications":testing.html|
|tmp/|Temporary files|
|vendor/|A place for all third-party code. In a typical Rails application, this includes Ruby Gems, the Rails source code (if you install it into your project) and plugins containing additional prepackaged functionality.|

h4. 设定资料库

几乎每一个Rails应用程式都会与资料库互动。而资料库需要一个设定档是 +config/database.yml+ 。如果你打开这个档案，你会发现预设设定是SQLite3。这个档案包含三个不同的部分，对应到三个Rails预设环境：

* The +development+ environment is used on your development computer as you interact manually with the application.
* The +test+ environment is used to run automated tests.
* The +production+ environment is used when you deploy your application for the world to use.

h5. 设定SQLite3 资料库

Rails预设内建支援 "SQLite3":http://www.sqlite.org ，这是一套非常轻量的非伺服器型资料库程式。虽然繁重的生产环境可能超过SQLite的负担，但是它却非常适合开发和测试时使用。Rails预设使用SQLite资料库来建立新的专案，当然你也可以稍后修改。

这里是一段有连接信息的开发用预设设定档（ <tt>config/database.yml</tt> ）：

<yaml>
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000
</yaml>

NOTE: 本指南使用SQLite3 资料库，因为它零配置就可以使用。Rails 当然也支援MySQL 跟PostgreSQL，也有其他资料库系统的插件。如果是正式的上线环境就会需要了。

h5. 设定MySQL 资料库

如果你选择使用MySQL取代预设的Sqlite3资料库，你的 +config/database.yml+ 会有点不同，以下是一个开发用的设定档：

<yaml>
development:
  adapter: mysql2
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
</yaml>

如果在你的开发用电脑 MySQL 安装时使用了 root 用户和空白密码，那么这个设定就可以直接用了。否则，请修改username 和password。

h5. 设定 PostgreSQL 资料库

最后，如果你选择使用 PostgreSQL，你的 +config/database.yml+ 可以设定成:

<yaml>
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:
</yaml>

h5. Configuring an SQLite3 Database for JRuby Platform

If you choose to use SQLite3 and using JRuby, your +config/database.yml+ will
look a little different. Here's the development section:

<yaml>
development:
  adapter: jdbcsqlite3
  database: db/development.sqlite3
</yaml>

h5. Configuring a MySQL Database for JRuby Platform

If you choose to use MySQL and using JRuby, your +config/database.yml+ will look
a little different. Here's the development section:

<yaml>
development:
  adapter: jdbcmysql
  database: blog_development
  username: root
  password:
</yaml>

h5. Configuring a PostgreSQL Database for JRuby Platform

Finally if you choose to use PostgreSQL and using JRuby, your
+config/database.yml+ will look a little different. Here's the development
section:

<yaml>
development:
  adapter: jdbcpostgresql
  encoding: unicode
  database: blog_development
  username: blog
  password:
</yaml>

Change the username and password in the +development+ section as appropriate.

TIP: You don't have to update the database configurations manually. If you look at the
options of the application generator, you will see that one of the options
is named <tt>--database</tt>. This option allows you to choose an adapter from a
list of the most used relational databases. You can even run the generator
repeatedly: <tt>cd .. && rails new blog --database=mysql</tt>. When you confirm the overwriting
 of the +config/database.yml+ file, your application will be configured for MySQL
instead of SQLite.

h4. 建立资料库

现在你的资料库设定妥当，是时候让 Rails 创建空的资料库了。输入以下的rake 指令：

<shell>
$ rake db:create
</shell>

这会在db/目录下建立development和test的SQLite3资料库。
This will create your development and test SQLite3 databases inside the
<tt>db/</tt> folder.

TIP: Rake是个在Rails中广泛运用的通用型command命令列工具，你可以输入rake -T列出所有可用的指令。
Rake is a general-purpose command-runner that Rails uses for many things.
You can see the list of available rake commands in your application by running
+rake -T+.

h3. 哈啰，Rails!

每学习一个新的程式语言，一开始都会有个输出Hello, World! 的最简单练习。为了办到这件事情，你需要启动Rails 应用程式的伺服器。
One of the traditional places to start with a new language is by getting some
text up on screen quickly. To do this, you need to get your Rails application
server running.

h4. 启动 Web 伺服器

其实你已经有了可以运作的Rails 应用程式了。要在你的开发机器上启动Web 伺服器，请输入：
You actually have a functional Rails application already. To see it, you need to
start a web server on your development machine. You can do this by running:

<shell>
$ rails server
</shell>

这会启动一个Mongrel (译注：或是WEBrick)伺服器(Rails也可以用其他的伺服器)。要看到结果，请打开浏览器前往http://localhost:3000。你应该就会看到Rails的预设首页。
This will fire up an instance of the WEBrick web server by default (Rails can
also use several other web servers). To see your application in action, open a
browser window and navigate to "http://localhost:3000":http://localhost:3000.
You should see Rails' default information page:

!images/rails_welcome.png(Welcome Aboard screenshot)!

TIP: 要关闭伺服器的话，请输入Ctrl+C。在development mode 开发模式的话，Rails 通常是不需要重新启动的，修改的档案会自动载入。(译注：如果是production mode 的话，修改任何档案都必须重新启动伺服器才会有效果)
To stop the web server, hit Ctrl+C in the terminal window where it's
running. In development mode, Rails does not generally require you to stop the
server; changes you make in files will be automatically picked up by the server.

这个“Welcome Aboard”的画面是Rails应用程式的冒烟测试(smoke test)：它确认了你的软体设定正确。你可以点击 About your application's environment的超连结看到应用程式的环境资讯摘要。
The "Welcome Aboard" page is the _smoke test_ for a new Rails application: it
makes sure that you have your software configured correctly enough to serve a
page. You can also click on the _About your application’s environment_ link to
see a summary of your application's environment.

h4. 说"Hello"，Rails

要让Rails 说"Hello"，你必须至少建立一个Controller 跟View。而我们用一个指令就可以办到了。在命令列视窗输入：

To get Rails saying "Hello", you need to create at minimum a controller and a
view. Fortunately, you can do that in a single command. Enter this command in
your terminal:

<shell>
$ rails generate controller home index
</shell>

TIP: 如果你在Windows上，或你的Ruby不像常见的设定，你可能需要改成输入ruby \path\to\rails controller home index。
If you get a command not found error when running this command, you
need to explicitly pass Rails +rails+ commands to Ruby: <tt>ruby
\path\to\your\application\script\rails generate controller home index</tt>.

Rails会新增几个档案，包括app/views/home/index.html.erb。这个样板(template)会被home controller里的index action (即index method函式)拿来显示给浏览器。用编辑器打开这个档案，加入以下程式码：
Rails will create several files for you, including
+app/views/home/index.html.erb+. This is the template that will be used to
display the results of the +index+ action (method) in the +home+ controller.
Open this file in your text editor and edit it to contain a single line of code:

<code class="html">
<h1>Hello, Rails!</h1>
</code>

h4. 设定首页Setting the Application Home Page

那现在我们有了Controller跟View，我们需要告诉Rails什么时候“Hello Rails”要出现。在这个例子里，我们希望把刚刚首页的http://localhost:3000的“Welcome Aboard”换掉，改成“Hello Rails”。
Now that we have made the controller and view, we need to tell Rails when we
want "Hello Rails" to show up. In our case, we want it to show up when we
navigate to the root URL of our site,
"http://localhost:3000":http://localhost:3000, instead of the "Welcome Aboard"
smoke test.

第一步是删除预设的首页档案：
The first step to doing this is to delete the default page from your application:

<shell>
$ rm public/index.html
</shell>

这是因为Rails会优先回传任何public下有的静态档案，而不是Controllers里面建立的动态内容。
We need to do this as Rails will deliver any static file in the +public+
directory in preference to any dynamic content we generate from the controllers.

接着，你必须要告诉Rails你真正的首页在哪里。用编辑器打开config/routes.rb这个档案。这是你的应用程式的路由档案(routing file)，它是个特殊的DSL (domain-specific language专属领域语言)告诉Rails如何将进来的HTTP请求派送到Controllers跟Actions。这个档案包含许多注解起来的范例，其中一行开头是:root to请把注解移掉如下：
Now, you have to tell Rails where your actual home page is located. Open the
file +config/routes.rb+ in your editor. This is your application's _routing
file_ which holds entries in a special DSL (domain-specific language) that tells
Rails how to connect incoming requests to controllers and actions. This file
contains many sample routes on commented lines, and one of them actually shows
you how to connect the root of your site to a specific controller and action.
Find the line beginning with +root :to+, uncomment it and change it like the
following:

<ruby>
Blog::Application.routes.draw do

  #...
  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  root :to => "home#index"
</ruby>

root :to => "home#index"这一行告诉Rails将root网址对应到home controller的index action。
The +root :to => "home#index"+ tells Rails to map the root action to the home
controller's index action.

接下来用浏览器打开http://localhost:3000，你就会看到Hello, Rails!了。
Now if you navigate to "http://localhost:3000":http://localhost:3000 in your
browser, you'll see +Hello, Rails!+.

NOTE. 关于更多路由的资讯，请参考Rails Routing from the Outside In .
For more information about routing, refer to "Rails Routing from the
Outside In":routing.html.

h3. 使用鹰架(scaffolding) 快速上手 Getting Up and Running Quickly with Scaffolding

Rails的鹰架(scaffolding)功能可以用一行指令就快速为Resource建立一组Model, Views跟Controller程式码。
Rails _scaffolding_ is a quick way to generate some of the major pieces of an
application. If you want to create the models, views, and controllers for a new
resource in a single operation, scaffolding is the tool for the job.

h3. 建立Resource Creating a Resource

在这个blog 的例子，你可以用鹰架建立Post resource：这将完成部落格文章管理功能。要办到这件事情，在命令列视窗输入：
In the case of the blog application, you can start by generating a scaffolded
Post resource: this will represent a single blog posting. To do this, enter this
command in your terminal:

<shell>
$ rails generate scaffold Post name:string title:string content:text
</shell>

鹰架(scaffold)产生器(generator)会建立出15 个档案在不同目录，以下是个简单的说明：
The scaffold generator will build several files in your application, along with some
folders, and edit <tt>config/routes.rb</tt>. Here's a quick overview of what it creates:

|_.File                                       |_.Purpose|
|db/migrate/20100207214725_create_posts.rb    |Migration to create the posts table in your database (your name will include a different timestamp)|
|app/models/post.rb                           |The Post model|
|test/fixtures/posts.yml                      |Dummy posts for use in testing|
|app/controllers/posts_controller.rb          |The Posts controller|
|app/views/posts/index.html.erb               |A view to display an index of all posts |
|app/views/posts/edit.html.erb                |A view to edit an existing post|
|app/views/posts/show.html.erb                |A view to display a single post|
|app/views/posts/new.html.erb                 |A view to create a new post|
|app/views/posts/_form.html.erb               |A partial to control the overall look and feel of the form used in edit and new views|
|app/helpers/posts_helper.rb                  |Helper functions to be used from the post views|
|app/assets/stylesheets/scaffolds.css.scss    |Cascading style sheet to make the scaffolded views look better|
|app/assets/stylesheets/posts.css.scss        |Cascading style sheet for the posts controller|
|app/assets/javascripts/posts.js.coffee       |CoffeeScript for the posts controller|
|test/unit/post_test.rb                       |Unit testing harness for the posts model|
|test/functional/posts_controller_test.rb     |Functional testing harness for the posts controller|
|test/unit/helpers/posts_helper_test.rb       |Unit testing harness for the posts helper|
|config/routes.rb                             |Edited to include routing information for posts|

NOTE. 虽然鹰架(scaffolding)可以帮助你快速上手，但是可没办法产生出完美符合需求的程式码。因此许多有经验的Rails 开发者根本不用鹰架(scaffolding)功能，而偏好从头打造起Models, Controllers 和Views。
While scaffolding will get you up and running quickly, the code it
generates is unlikely to be a perfect fit for your application. You'll most
probably want to customize the generated code. Many experienced Rails developers
avoid scaffolding entirely, preferring to write all or most of their source code
from scratch. Rails, however, makes it really simple to customize templates for
generated models, controllers, views and other source files. You'll find more
information in the "Creating and Customizing Rails Generators &
Templates":generators.html guide.

h4. 运行迁移

rails generate scaffold产生出来的程式中，有一项是资料库迁移(database migration)。Migration是种Ruby类别用来方便建立和修改资料库资料表。Rails使用rake指令来执行migrations，而且它也支援可以逆推migration步骤。Migration的档名包含了timestamp (时间戳章)，用来确保它们可以依照建立时间依序执行。
One of the products of the +rails generate scaffold+ command is a _database
migration_. Migrations are Ruby classes that are designed to make it simple to
create and modify database tables. Rails uses rake commands to run migrations,
and it's possible to undo a migration after it's been applied to your database.
Migration filenames include a timestamp to ensure that they're processed in the
order that they were created.

如果你仔细看看db/migrate/20100207214725_create_posts.rb这个档案(记住，你的档名开头会有点不一样)，你会看到：
If you look in the +db/migrate/20100207214725_create_posts.rb+ file (remember,
yours will have a slightly different name), here's what you'll find:

<ruby>
class CreatePosts < ActiveRecord::Migration
  def change
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end
end
</ruby>

以上的Migration有两个函式，up会在migration进资料库时执行，而down则会在之后需要逆推的时候执行。在这个例子中up 会建立posts资料表，包含两个string栏位和一个text栏位。它也会建立两个timestamp栏位(译注: t.timestamps该行等同于t.datetime :created_at和t.datetime :updated_at)用来追踪建立和最后修改时间。更多的Rails migrations资讯请参考Rails Database Migrations。
The above migration creates a method named +change+ which will be called when you
run this migration. The action defined in that method is also reversible, which
means Rails knows how to reverse the change made by this migration, in case you
want to reverse it at later date. By default, when you run this migration it
will creates a +posts+ table with two string columns and a text column. It also
creates two timestamp fields to track record creation and updating. More
information about Rails migrations can be found in the "Rails Database
Migrations":migrations.html guide.

这时你可以用以下的rake 指令执行Migration：
At this point, you can use a rake command to run the migration:

<shell>
$ rake db:migrate
</shell>

Rails 就会执行这个migration 命令，然后告诉你它建立了Posts 资料表。
Rails will execute this migration command and tell you it created the Posts
table.

<shell>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
</shell>

NOTE. 因为预设是跑在development模式，这个指令会用config/database.yml设定里的development那段所指定的资料库。
Because you're working in the development environment by default, this
command will apply to the database defined in the +development+ section of your
+config/database.yml+ file. If you would like to execute migrations in other
environment, for instance in production, you must explicitly pass it when
invoking the command: <tt>rake db:migrate RAILS_ENV=production</tt>.

h4. 增加链接

为了能把文章列表加到我们已经建好的首页，你可以放个超连结在首页上。打开app/views/home/index.html.erb修改成：
To hook the posts up to the home page you've already created, you can add a link
to the home page. Open +app/views/home/index.html.erb+ and modify it as follows:

<ruby>
<h1>Hello, Rails!</h1>
<%= link_to "My Blog", posts_path %>
</ruby>

这个link_to函式是Rails内建的view helpers (View的辅助函式)。它会建立一个文字超连结，连到文章列表。
The +link_to+ method is one of Rails' built-in view helpers. It creates a
hyperlink based on text to display and where to go - in this case, to the path
for posts.

h4. 在浏览器中操作帖子

好，你已经准备好可以进入文章列表了，请浏览http://localhost:3000然后点击“My Blog”连结：
Now you're ready to start working with posts. To do that, navigate to
"http://localhost:3000":http://localhost:3000/ and then click the "My Blog"
link:

!images/posts_index.png(Posts Index screenshot)!

这就是Rails执行index view文章页面的结果。目前资料库里面还没有任何文章，如果你点选New Post超连结，就可以新增一篇文章。有了文章之后，你就可以编辑、详细 ​​浏览或删除。所有的逻辑和HTML都被内建的rails generate scaffold指令搞定了。
This is the result of Rails rendering the +index+ view of your posts. There
aren't currently any posts in the database, but if you click the +New Post+ link
you can create one. After that, you'll find that you can edit posts, look at
their details, or destroy them. All of the logic and HTML to handle this was
built by the single +rails generate scaffold+ command.

TIP: 在development模式中(也就是目前的预设环境)，Rails每次浏览器来HTTP请求都会重新载入程式，所以不需要重新启动伺服器。
In development mode (which is what you're working in by default), Rails
reloads your application with every browser request, so there's no need to stop
and restart the web server.

在development模式中(也就是目前的预设环境)，Rails每次浏览器来HTTP请求都会重新载入程式，所以不需要重新启动伺服器。
Congratulations, you're riding the rails! Now it's time to see how it all works.

h4. The Model

app/models/post.rb就是Model档案，它非常简单：
The model file, +app/models/post.rb+ is about as simple as it can get:

<ruby>
class Post < ActiveRecord::Base
end
</ruby>

程式码不多，但是注意Post类别继承了ActiveRecord::Base。Active Record让你的Model有非常多功能，包括基本的资料库CRUD操作(Create, Read, Update, Destroy，新增、浏览、更新、删除)、资料验证(data validation)、厉害的搜寻以及可以和其他Models关联在一起。
There isn't much to this file - but note that the +Post+ class inherits from
+ActiveRecord::Base+. Active Record supplies a great deal of functionality to
your Rails models for free, including basic database CRUD (Create, Read, Update,
Destroy) operations, data validation, as well as sophisticated search support
and the ability to relate multiple models to one another.

h4. 添加一些验证

Rails提供一些函式帮助你验证资料的正确性，编辑app/models/post.rb这个档案：
Rails includes methods to help you validate the data that you send to models.
Open the +app/models/post.rb+ file and edit it:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
end
</ruby>

这几行程式会确保所有储存的文章一定会有name 和title 的资料，而且title 至少有五个字元长度。Rails 提供各种验证的方法，包括必填、唯一性、格式或是需要有关联物件。
These changes will ensure that all posts have a name and a title, and that the
title is at least five characters long. Rails can validate a variety of
conditions in a model, including the presence or uniqueness of columns, their
format, and the existence of associated objects.

h4. 使用Console 主控台Using the Console

要看到validations 的作用，你可以使用console。console 是一种命令列工具可以让你在Rails 中的环境中执行Ruby 程式：
To see your validations in action, you can use the console. The console is a
command-line tool that lets you execute Ruby code in the context of your
application:

<shell>
$ rails console
</shell>

TIP: The default console will make changes to your database. You can instead
open a console that will roll back any changes you make by using +rails console
--sandbox+.

在 Console 载入之后，你就可以在里面使用Models：
After the console loads, you can use it to work with your application's models:

<shell>
>> p = Post.new(:content => "A new post")
=> #<Post id: nil, name: nil, title: nil,
     content: "A new post", created_at: nil,
     updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<OrderedHash { :title=>["can't be blank",
                           "is too short (minimum is 5 characters)"],
                   :name=>["can't be blank"] }>
</shell>

这段程式先建立了一个Post实例，试图要储存进资料库，但是却回传false (表示储存失败)，然后观察文章的errors。
This code shows creating a new +Post+ instance, attempting to save it and
getting +false+ for a return value (indicating that the save failed), and
inspecting the +errors+ of the post.

当你完成之后，输入exit按下enter来离开主控台(Console)。
When you're finished, type +exit+ and hit +return+ to exit the console.

TIP: 不像在development模式，console不会自动载入刚修改的程式。如果你在console开启之后才修改程式，请输入reload!重新载入。
Unlike the development web server, the console does not automatically load
your code afresh for each line. If you make changes to your models while the
console is open, type +reload!+ at the console prompt to load them.

h4. 列出所有文章

最容易开始上手的地方就是列出文章的程式码了。请打开app/controllers/posts_controller.rb这个档案，然后看看 index+这个action：
The easiest place to start looking at functionality is with the code that lists
all posts. Open the file +app/controllers/posts_controller.rb+ and look at the
+index+ action:

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html  # index.html.erb
    format.json  { render :json => @posts }
  end
end
</ruby>

Post.all会呼叫Post model回传资料库里所有的文章，结果会是一个包含文章的@posts阵列。
+Post.all+ calls the +Post+ model to return all of the posts currently in the
database. The result of this call is an array of posts that we store in an
instance variable called +@posts+.

TIP: 关于更多Active Reocrd资料查询的功能，请查阅Active Record Query Interface .
For more information on finding records with Active Record, see "Active
Record Query Interface":active_record_querying.html.

这个respond_to block (程式码区块)同时处理了HTML和XML请求。如果浏览器浏览http://localhost:3000/posts.xml你就会看到XML格式。HTML格式则会去找app/views/posts/下符合action名称的档案。Rails会让所有action里的实例变数(instance variables)(译注:也就是有@开头的变数)通通传到View里面可以使用。以下是app/views/posts/index.html.erb :
The +respond_to+ block handles both HTML and JSON calls to this action. If you
browse to "http://localhost:3000/posts.json":http://localhost:3000/posts.json,
you'll see a JSON containing all of the posts. The HTML format looks for a view
in +app/views/posts/+ with a name that corresponds to the action name. Rails
makes all of the instance variables from the action available to the view.
Here's +app/views/posts/index.html.erb+:

<erb>
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.name %></td>
    <td><%= post.title %></td>
    <td><%= post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
</erb>

这个view迭代了@posts阵列并显示内容跟超连结，有几件值得注意的事情：
This view iterates over the contents of the +@posts+ array to display content
and links. A few things to note in the view:

* +link_to+ builds a hyperlink to a particular destination
* +edit_post_path+ and +new_post_path+ are helpers that Rails provides as part of RESTful routing. You'll see a variety of these helpers for the different actions that the controller includes.

NOTE. 之前的Rails版本中，你必须使用<%=h post.name %>如此HTML才会被逸出(译注：可以防止XSS网路攻击)。在Rais 3.0中预设就会逸出。如果不要逸出，请使用<%= raw post.name %>。
In previous versions of Rails, you had to use +&lt;%=h post.name %&gt;+ so
that any HTML would be escaped before being inserted into the page. In Rails
3.0, this is now the default. To get unescaped HTML, you now use +&lt;%= raw
post.name %&gt;+.

TIP: 关于更多rendering的处理，请参阅Layouts and Rendering in Rails .
For more details on the rendering process, see "Layouts and Rendering in
Rails":layouts_and_rendering.html.

h4. 客制化Layout 版型Customizing the Layout

View只是Rails处理HTML的一个环节，还有一项概念叫做layouts，可以用来包裹views。当Rails要显示一个view给浏览器时，它会将view的HTML放到layout的HTML里面去。在之前的Rails版本，rails generate scaffold指令会自动为每个controller建立一个layout，例如app/views/layouts/posts.html.erb就是给posts controller的。但是在Rails 3.0的scaffold改了，所有的controllers共用一个layout档案叫做app/views/layouts/application.html.erb。打开这个档案然后修改它的body标签：
The view is only part of the story of how HTML is displayed in your web browser.
Rails also has the concept of +layouts+, which are containers for views. When
Rails renders a view to the browser, it does so by putting the view's HTML into
a layout's HTML. In previous versions of Rails, the +rails generate scaffold+
command would automatically create a controller specific layout, like
+app/views/layouts/posts.html.erb+, for the posts controller. However this has
been changed in Rails 3.0. An application specific +layout+ is used for all the
controllers and can be found in +app/views/layouts/application.html.erb+. Open
this layout in your editor and modify the +body+ tag:

<erb>
<!DOCTYPE html>
<html>
<head>
  <title>Blog</title>
  <%= stylesheet_link_tag "application" %>
  <%= javascript_include_tag "application" %>
  <%= csrf_meta_tags %>
</head>
<body style="background: #EEEEEE;">

<%= yield %>

</body>
</html>
</erb>

浏览器重新整理/posts页面，你会看到灰色的背景。同样的背景也会出现在所有的文章views。Now when you refresh the +/posts+ page, you'll see a gray background to the
page. This same gray background will be used throughout all the views for posts.

h4. 建立新文章Creating New Posts

建立一篇新的文章需要两个actions。第一个是new action，它用来实例化一个空的Post物件：
Creating a new post involves two actions. The first is the +new+ action, which
instantiates an empty +Post+ object:

<ruby>
def new
  @post = Post.new

  respond_to do |format|
    format.html  # new.html.erb
    format.json  { render :json => @post }
  end
end
</ruby>

这个new.html.erb view会显示空的Post给使用者：
The +new.html.erb+ view displays this empty Post to the user:

<erb>
<h1>New post</h1>

<%= render 'form' %>

<%= link_to 'Back', posts_path %>
</erb>

其中<%= render 'form' %>是你第一次遇到partials。partial是一个包含HTML和Ruby程式的片段，可以在其他地方重复使用。在这个例子中，表单被用在新增文章，基本上跟编辑文章的表单相同，两者都有相同的name跟title文字栏位跟content文字区块栏位，以及送出按钮。
The +&lt;%= render 'form' %&gt;+ line is our first introduction to _partials_ in
Rails. A partial is a snippet of HTML and Ruby code that can be reused in
multiple locations. In this case, the form used to make a new post, is basically
identical to a form used to edit a post, both have text fields for the name and
title and a text area for the content with a button to make a new post or update
the existing post.

如果看清楚views/posts/_form.html.erb这个档案，内容如下：
If you take a look at +views/posts/_form.html.erb+ file, you will see the following:

<erb>
<%= form_for(@post) do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </div>
  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

这个partial 接收了来自view 的所有的实例变数(instance variables)。在这个例子中，controller 中设定了@post 是新的Post 物件，所以在view 跟这个partial 中也都有这个@post 物件。
This partial receives all the instance variables defined in the calling view
file, so in this case, the controller assigned the new Post object to +@post+
and so, this is available in both the view and partial as +@post+.

想知道更多partials的资讯，请参阅Layouts and Rendering in Rails。
For more information on partials, refer to the "Layouts and Rendering in
Rails":layouts_and_rendering.html#using-partials guide.

这个form_for block (程式码区块)被用来建立HTML表单。在block之中，你可以使用各种函式来建构表单。例如f.text_field :name建立出一个文字输入框，并填入@post的name属性资料。但这个表单只能基于这个model有的属性(在这个例子是name、title跟content )。Rails偏好使用form_for而不是让你手写表单HTML，这是因为程式码可以更加简洁，而且可以明确地绑在一个model实例上。
The +form_for+ block is used to create an HTML form. Within this block, you have
access to methods to build various controls on the form. For example,
+f.text_field :name+ tells Rails to create a text input on the form, and to hook
it up to the +name+ attribute of the instance being displayed. You can only use
these methods with attributes of the model that the form is based on (in this
case +name+, +title+, and +content+). Rails uses +form_for+ in preference to
having you write raw HTML because the code is more succinct, and because it
explicitly ties the form to a particular model instance.

form_for block也非常聪明，不同的New Post跟Edit Post表单action属性跟送出按钮的文字也会跟着不同(译注:根据@post的不同，前者是全新的，后者是已经建立过的)。
The +form_for+ block is also smart enough to work out if you are doing a _New
Post_ or an _Edit Post_ action, and will set the form +action+ tags and submit
button names appropriately in the HTML output.

TIP: 如果你需要建立任意栏位的HTML表单，而不绑在某一个model上，你可以使用form_tag函式。它也提供了建构表单的函式而不需要绑在model实例上。
If you need to create an HTML form that displays arbitrary fields, not tied
to a model, you should use the +form_tag+ method, which provides shortcuts for
building forms that are not necessarily tied to a model instance.

当使用者点击表单的Create Post按钮时，浏览器就会送出资料到controller的create函式(Rails会知道要呼叫create函式，这是因为表单是用HTTP POST请求的，这是个稍早提过的RESTful惯例):
When the user clicks the +Create Post+ button on this form, the browser will
send information back to the +create+ method of the controller (Rails knows to
call the +create+ method because the form is sent with an HTTP POST request;
that's one of the conventions that I mentioned earlier):

<ruby>
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      format.html  { redirect_to(@post,
                    :notice => 'Post was successfully created.') }
      format.json  { render :json => @post,
                    :status => :created, :location => @post }
    else
      format.html  { render :action => "new" }
      format.json  { render :json => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

create action会透过从表单传进来的资料，也就是Rails提供的params hash杂凑，来实例化一个新的Post物件。成功储存之后，create会根据使用者的请求回传适当的格式(在这个例子是HTML )。这里它是把使用者导向(redirect)到show action显示文章内容，并设定notice提醒使用者Post已经成功被建立。
The +create+ action instantiates a new Post object from the data supplied by the
user on the form, which Rails makes available in the +params+ hash. After
successfully saving the new post, +create+ returns the appropriate format that
the user has requested (HTML in our case). It then redirects the user to the
resulting post +show+ action and sets a notice to the user that the Post was
successfully created.

如果文章因为validation错误而储存失败，这里会回传给使用者带有错误讯息的new action，好让使用者可以修正问题再试一次。(译注：render :action => "new"会回传new action使用的样板，而不是执行new action这个函式。如果改成使用redirect_to new_post_path则会让浏览器重新发送请求到new action，但是如此一来@post就被重新建立而失去使用者刚输入的资料)
If the post was not successfully saved, due to a validation error, then the
controller returns the user back to the +new+ action with any error messages so
that the user has the chance to fix the error and try again.

“Post was successfully created”的讯息会被储存在Rails的flash hash里(通常就称作Flash)好让讯息可以被带到另一个action，它可以提供使用者一些有用的资讯。在这个create的action中，使用者并没有真的看到任何页面，因为它马上就被导向到新的文章页面。而这个Flash就带着讯息到下一个action，好让使用者在show action页面看到“Post was successfully created.”这个讯息。
The "Post was successfully created." message is stored inside of the Rails
+flash+ hash, (usually just called _the flash_) so that messages can be carried
over to another action, providing the user with useful information on the status
of their request. In the case of +create+, the user never actually sees any page
rendered during the Post creation process, because it immediately redirects to
the new Post as soon Rails saves the record. The Flash carries over a message to
the next action, so that when the user is redirected back to the +show+ action,
they are presented with a message saying "Post was successfully created."

h4. 显示个别文章 Showing an Individual Post

当你在index页面点击show的文章连结，就会前往如http://localhost:3000/posts/1的网址。Rails会针对这个resource去呼叫show action，然后传进1到id参数。以下是show action。
When you click the +show+ link for a post on the index page, it will bring you
to a URL like +http://localhost:3000/posts/1+. Rails interprets this as a call
to the +show+ action for the resource, and passes in +1+ as the +:id+ parameter.
Here's the +show+ action:

<ruby>
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html  # show.html.erb
    format.json  { render :json => @post }
  end
end
</ruby>

这个show action根据id值使用Post.find从资料库中找出该篇文章。找到资料之后，Rails用show.html.erb显示出来：
The +show+ action uses +Post.find+ to search for a single record in the database
by its id value. After finding the record, Rails displays it by using
+show.html.erb+:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
</erb>

h4. 编辑文章Editing Posts

如同建立新文章，编辑文章也有两个步骤。第一个是请求特定一篇文章的edit_post_path(@post)页面。这会呼叫controller的 +edit+ action：
Like creating a new post, editing a post is a two-part process. The first step
is a request to +edit_post_path(@post)+ with a particular post. This calls the
+edit+ action in the controller:

<ruby>
def edit
  @post = Post.find(params[:id])
end
</ruby>

找到要编辑的文章之后，Rails显示edit.html.erb页面：
After finding the requested post, Rails uses the +edit.html.erb+ view to display it:

<erb>
<h1>Editing post</h1>

<%= render 'form' %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
</erb>

这里也像new action，edit action使用form partial，只是这一次表单会用HTTP PUT动作给PostsController，而且送出按钮的字样变成“Update Post”。
Again, as with the +new+ action, the +edit+ action is using the +form+ partial,
this time however, the form will do a PUT action to the PostsController and the
submit button will display "Update Post"

送出表单后，会呼叫controller的update action：
Submitting the form created by this view will invoke the +update+ action within
the controller:

<ruby>
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      format.html  { redirect_to(@post,
                    :notice => 'Post was successfully updated.') }
      format.json  { render :json => {}, :status => :ok }
    else
      format.html  { render :action => "edit" }
      format.json  { render :json => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

在update action里，Rails透过:id参数找到要编辑的资料。接着update_attributes会根据表单传进来的参数修改到资料上。如果一切正常，使用者会被导向到文章的show页面。如果验证有任何问题，它会显示edit页面好让使用者可以修正资料。
In the +update+ action, Rails first uses the +:id+ parameter passed back from
the edit view to locate the database record that's being edited. The
+update_attributes+ call then takes the rest of the parameters from the request
and applies them to this record. If all goes well, the user is redirected to the
post's +show+ view. If there are any problems, it's back to the +edit+ view to
correct them.

h4. 删除文章Destroying a Post

最后，点击destroy超连结会呼叫destroy action：
Finally, clicking one of the +destroy+ links sends the associated id to the
+destroy+ action:

<ruby>
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to posts_url }
    format.json { head :ok }
  end
end
</ruby>

Active Record model的destroy方法会删除对应的资料库资料。完成之后，就没办法显示啰，所以Rails将使用者导向这个model的index页面。
The +destroy+ method of an Active Record model instance removes the
corresponding record from the database. After that's done, there isn't any
record to display, so Rails redirects the user's browser to the index view for
the model.

h3. 新增第二个Model Adding a Second Model

你已经完成用scaffolding 功能建立一个model 了，接下来让我们再新增第二个model。第二个model 是部落格文章的留言。
Now that you've seen how a model built with scaffolding looks like, it's time to
add a second model to the application. The second model will handle comments on
blog posts.

h4. 产生Model Generating a Model

Rails 的Models 名称都是单数名词，而它们对应的资料库资料表是复数名词，这个惯例也适用在新的model 名字：Comment。即使你完全不用scaffolding，大部分的Rails 开发者也都会用产生器(generators)来产生models 及controllers 档案。要建立一个新的model，请在命令列视窗中输入：
Models in Rails use a singular name, and their corresponding database tables use
a plural name. For the model to hold comments, the convention is to use the name
Comment. Even if you don't want to use the entire apparatus set up by
scaffolding, most Rails developers still use generators to make things like
models and controllers. To create the new model, run this command in your
terminal:

<shell>
$ rails generate model Comment commenter:string body:text post:references
</shell>

这个指令会生成以下档案：
This command will generate four files:

* +app/models/comment.rb+ - The model
* +db/migrate/20100207235629_create_comments.rb+ - The migration
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - The test harness.

首先，让我们看一下comment.rb：
First, take a look at +comment.rb+:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

这看起来跟先前的post.rb model非常像。差别是多了一行belongs_to :post，这会设定Active Record的association(关联)。你将会在下一节学到更多associations的知识。
This is very similar to the +post.rb+ model that you saw earlier. The difference
is the line +belongs_to :post+, which sets up an Active Record _association_.
You'll learn a little about associations in the next section of this guide.

除了model，Rails 也会建立对应的资料库资料表migration：
In addition to the model, Rails has also made a migration to create the
corresponding database table:

<ruby>
class CreateComments < ActiveRecord::Migration
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end

    add_index :comments, :post_id
  end
end
</ruby>

注意到t.references这一行会帮关联的models建立foreign key (外部键)栏位(译注：等同于t.integer :post_id )。接着让我们执行Migration：
The +t.references+ line sets up a foreign key column for the association between
the two models. And the +add_index+ line sets up an index for this association
column. Go ahead and run the migration:

<shell>
$ rake db:migrate
</shell>

Rails 很聪明只会执行还没有执行过的Migrations，所以在这个例子中，我们只会看到：
Rails is smart enough to only execute the migrations that have not already been
run against the current database, so in this case you will just see:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. 把 Models 关联起来Associating Models

Active Record associations 让你可以轻易宣告两个Models 之间的关系。在这个文章跟留言的例子，你可以写出以下的关系：
Active Record associations let you easily declare the relationship between two
models. In the case of comments and posts, you could write out the relationships
this way:

* Each comment belongs to one post
* One post can have many comments

事实上，这就非常接近Rails 用来宣告关系的语法了。你已经见到Comment model 里面的程式码，宣告了每篇留言属于一篇文章：
In fact, this is very close to the syntax that Rails uses to declare this
association. You've already seen the line of code inside the Comment model that
makes each comment belong to a Post:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

你会需要编辑post.rb档案加上另一头的关联宣告：
You'll need to edit the +post.rb+ file to add the other side of the association:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

这两行宣告语法产生了一些神奇的行为。例如，如果你有一篇文章的实例变数@post，你就可以透过@post.comments拿到所有的留言阵列了。
These two declarations enable a good bit of automatic behavior. For example, if
you have an instance variable +@post+ containing a post, you can retrieve all
the comments belonging to that post as the array +@post.comments+.

TIP: 关于更多Active Record associations的资讯，请参阅Active Record Associations .
For more information on Active Record associations, see the "Active Record
Associations":association_basics.html guide.

h4. 为留言新增URL路由Adding a Route for Comments

如同home controller，我们也需要新增路由告诉Rails如何浏览comments。再次打开config/routes.rb，你会看到一段之前由scaffold产生器为posts产生的resources :posts程式码，请修改成：
As with the +home+ controller, we will need to add a route so that Rails knows
where we would like to navigate to see +comments+. Open up the
+config/routes.rb+ file again, you will see an entry that was added
automatically for +posts+ near the top by the scaffold generator, +resources
:posts+, edit it as follows:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

这会在posts里建立一个comments的nested resource (嵌套resource)。这也描述了文章和留言有着阶层关系。
This creates +comments+ as a _nested resource_ within +posts+. This is another
part of capturing the hierarchical relationship that exists between posts and
comments.

TIP: 关于路由的更多资讯，请参阅Rails Routing from the Outside In
For more information on routing, see the "Rails Routing from the Outside
In":routing.html guide.

h4. 产生Controller Generating a Controller

有了Model，我们来把注意力放到如何建立对应的controller。再一次使用产生器：
With the model in hand, you can turn your attention to creating a matching
controller. Again, there's a generator for this:

<shell>
$ rails generate controller Comments
</shell>

这会建立六个档案和一个空目录：
This creates six files and one empty directory:

* +app/controllers/comments_controller.rb+ - The controller
* +app/helpers/comments_helper.rb+ - A view helper file
* +test/functional/comments_controller_test.rb+ - The functional tests for the controller
* +test/unit/helpers/comments_helper_test.rb+ - The unit tests for the helper
* +app/views/comments/+ - Views of the controller are stored here
* +app/assets/stylesheets/comment.css.scss+ - Cascading style sheet for the controller
* +app/assets/javascripts/comment.js.coffee+ - CoffeeScript for the controller

就像任何部落格，我们的读者可以在看完文章之后留言，然后回到文章页面看到刚刚的留言。所以，我们的CommentsController会提供函式可以建立留言跟删除垃圾留言。
Like with any blog, our readers will create their comments directly after
reading the post, and once they have added their comment, will be sent back to
the post show page to see their comment now listed. Due to this, our
+CommentsController+ is there to provide a method to create comments and delete
SPAM comments when they arrive.

首先，让我们修改Post的show样板( /app/views/posts/show.html.erb )好让我们可以新增留言：
So first, we'll wire up the Post show template
(+/app/views/posts/show.html.erb+) to let us make a new comment:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

我们在Post show页面新增了一个表单可以建立新留言，这个表单送出后会呼叫CommentsController的create action。让我们继续：
This adds a form on the Post show page that creates a new comment, which will
call the +CommentsController+ +create+ action, so let's wire that up:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

看起来比之前的posts controller 复杂一点。这是因为有了阶层关系。每一篇留言必须追踪它是属于哪一篇文章，因此需要一开始就得用find 找到所属的Post model。
You'll see a bit more complexity here than you did in the controller for posts.
That's a side-effect of the nesting that you've set up; each request for a
comment has to keep track of the post to which the comment is attached, thus the
initial find action to the Post model to get the post in question.

此外，这里也用到一些association所提供的函式。我们在@post.comments上使用create函式来新增并储存。这会自动关联起该留言属于该特定文章。
In addition, the code takes advantage of some of the methods available for an
association. We use the +create+ method on +@post.comments+ to create and save
the comment. This will automatically link the comment so that it belongs to that
particular post.

一旦我们完成新增留言，我们使用post_path(@post) helper来把使用者重新导向到本来的文章页面。这我们之前看过了，会呼叫PostsController的show action显示show.html.erb样板。这个页面也将用来显示留言，让我们在app/views/posts/show.html.erb新增以下程式码：
Once we have made the new comment, we send the user back to the original post
using the +post_path(@post)+ helper. As we have already seen, this calls the
+show+ action of the +PostsController+ which in turn renders the +show.html.erb+
template. This is where we want the comment to show, so let's add that to the
+app/views/posts/show.html.erb+.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Commenter:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Comment:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

现在我们可以在你的部落格上新增文​​章跟留言了。
Now you can add posts and comments to your blog and have them show up in the
right places.

h3. 重构

文章跟留言都可以运作了，但是如果我们看看app/views/posts/show.html.erb样板，实在有点又臭又长。我们可以利用partials来加以改善。
Now that we have Posts and Comments working, if we take a look at the
+app/views/posts/show.html.erb+ template, it's getting long and awkward. We can
use partials to clean this up.

h4. 显示Partial Collections (集合)Rendering Partial Collections

首先，我们来建立一个partial来显示文章的所有留言。新增app/views/comments/_comment.html.erb档案加入以下程式：
First we will make a comment partial to extract showing all the comments for the
post. Create the file +app/views/comments/_comment.html.erb+ and put the
following into it:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>
</erb>

然后修改app/views/posts/show.html.erb如下：
Then in the +app/views/posts/show.html.erb+ you can change it to look like the
following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This will now render the partial in +app/views/comments/_comment.html.erb+ once
for each comment that is in the +@post.comments+ collection. As the +render+
method iterates over the <tt>@post.comments</tt> collection, it assigns each
comment to a local variable named the same as the partial, in this case
+comment+ which is then available in the partial for us to show.

h4. 显示Partial 表单 Rendering a Partial Form

让我们也把新增留言的部分移到partial去吧。同样地，我们新增app/views/comments/_form.html.erb内容是：
Let's also move that new comment section out to its own partial. Again, you
create a file +app/views/comments/_form.html.erb+ and in it you put:

<erb>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

然后编辑app/views/posts/show.html.erb如下：
Then you make the +app/views/posts/show.html.erb+ look like the following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

其中第二个render定义了要显示comments/form这个样板，Rails会根据其中的斜线去找app/views/comments目录下的_form.html.erb档案。
The second render just defines the partial template we want to render,
<tt>comments/form</tt>, Rails is smart enough to spot the forward slash in that
string and realize that you want to render the <tt>_form.html.erb</tt> file in
the <tt>app/views/comments</tt> directory.

因为@posts被定义成实例变数(instance variable)，所以可以在所有的partials中读取到。
The +@post+ object is available to any partials rendered in the view because we
defined it as an instance variable.

h3. 删除留言

另一个部落格的重要功能是可以删除垃圾留言。要办到这件事，我们需要在view中有个超连结，以及在controller中实作DELETE动作。
Another important feature on a blog is being able to delete SPAM comments. To do
this, we need to implement a link of some sort in the view and a +DELETE+ action
in the +CommentsController+.

首先，让我们在app/views/comments/_comment.html.erb partial加上删除的超连结：
So first, let's add the delete link in the
+app/views/comments/_comment.html.erb+ partial:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               :confirm => 'Are you sure?',
               :method => :delete %>
</p>
</erb>

点击“Destroy Comment”连结会送出DELETE /posts/:id/comments/:id到CommentsController，我们接下来要找到要删除的留言，让我们在controller里加入destroy action：
Clicking this new "Destroy Comment" link will fire off a <tt>DELETE
/posts/:id/comments/:id</tt> to our +CommentsController+, which can then use
this to find the comment we want to delete, so let's add a destroy action to our
controller:

<ruby>
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</ruby>

这个destroy action会先找到所属的文章，然后透过这篇文章的@post.comments集合找到该留言，接着从资料库中移除，最后把使用者导向show action。
The +destroy+ action will find the post we are looking at, locate the comment
within the <tt>@post.comments</tt> collection, and then remove it from the
database and send us back to the show action for the post.


h4. 删除关联的对象

如果你要删除一篇文章，那么其关联的留言也需要被一起删除。不然的话这些留言只会白白占据你的资料库。Rails支援在association关联上使用dependent选项来解决这件事情。修改Post model，即app/models/post.rb如下：
If you delete a post then its associated comments will also need to be deleted.
Otherwise they would simply occupy space in the database. Rails allows you to
use the +dependent+ option of an association to achieve this. Modify the Post
model, +app/models/post.rb+, as follows:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
  has_many :comments, :dependent => :destroy
end
</ruby>

h3. 安全性Security

如果你打算发布这个部落格，任何人都可以新增、修改、删除文章或删除留言。
If you were to publish your blog online, anybody would be able to add, edit and
delete posts or delete comments.

Rails内建了一个非常简单的HTTP认证系统可以处理这种情形。首先，我们在app/controllers/application_controller.rb启用simple HTTP based authentication：
Rails provides a very simple HTTP authentication system that will work nicely in
this situation.

当然你可以修改成你想要的使用者名称和密码。我们把这个函式放进ApplicationController里，如此所有controller都可以使用(译注：因为所有的controller都继承自ApplicationController )。
接着在PostsController里，我们要对需要认证的actions加上权限检查，这里我们使用Rails的before_filter函式，它允许我们在执行特定的actions前先执行指定的函式，而我们在这个函式中检查使用者是否有权限。
In the +PostsController+ we need to have a way to block access to the various
actions if the person is not authenticated, here we can use the Rails
<tt>http_basic_authenticate_with</tt> method, allowing access to the requested
action if that method allows it.

我们在PostsController的上方来加入before filter。在这个例子中，我们希望使用者验证除了index跟show之外的所有action，请这么写：
To use the authentication system, we specify it at the top of our
+PostsController+, in this case, we want the user to be authenticated on every
action, except for +index+ and +show+, so we write that:

<ruby>
class PostsController < ApplicationController

  http_basic_authenticate_with :name => "dhh", :password => "secret", :except => [:index, :show]

  # GET /posts
  # GET /posts.json
  def index
    @posts = Post.all
    respond_to do |format|
# snipped for brevity
</ruby>

我们也希望有权限的使用者才可以删除留言，所以在CommentsController加上：
We also only want to allow authenticated users to delete comments, so in the
+CommentsController+ we write:

<ruby>
class CommentsController < ApplicationController

  http_basic_authenticate_with :name => "dhh", :password => "secret", :only => :destroy

  def create
    @post = Post.find(params[:post_id])
# snipped for brevity
</ruby>

这样当你试着建立一篇新文章，你会需要先经过basic HTTP Authentication认证。
Now if you try to create a new post, you will be greeted with a basic HTTP
Authentication challenge

!images/challenge.png(Basic HTTP Authentication Challenge)!

h3. 建立一个有多个Model 的表单Building a Multi-Model Form

另一个部落格常见的功能是可以为文章下标签(tag)。要实作这个功能，你的应用程式必须在一个表单中操作不只一个model。Rails 提供了nested forms (内嵌的表单)。
Another feature of your average blog is the ability to tag posts. To implement
this feature your application needs to interact with more than one model on a
single form. Rails offers support for nested forms.

要示范这项功能，我们将在你新增文章的地方，也可以顺便下标签。首先，建立一个新的标签Model：
To demonstrate this, we will add support for giving each post multiple tags,
right in the form where you create the post. First, create a new model to hold
the tags:

<shell>
$ rails generate model tag name:string post:references
</shell>

同样的，执行migration 来建立资料表：Again, run the migration to create the database table:

<shell>
$ rake db:migrate
</shell>

接着，编辑post.rb档案来建立关联。接着告诉Rails (透过accepts_nested_attributes marco巨集)你希望透过文章来设定标签：
Next, edit the +post.rb+ file to create the other side of the association, and
to tell Rails (via the +accepts_nested_attributes_for+ macro) that you intend to
edit tags via posts:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments, :dependent => :destroy
  has_many :tags

  accepts_nested_attributes_for :tags, :allow_destroy => :true,
    :reject_if => proc { |attrs| attrs.all? { |k, v| v.blank? } }
end
</ruby>

其中的:allow_destroy选项告诉Rails在稍后的view中会显示“remove” checkbox。而:reject_if选项会阻止储存空的标签。
The +:allow_destroy+ option on the nested attribute declaration tells Rails to
display a "remove" checkbox on the view that you'll build shortly. The
+:reject_if+ option prevents saving new tags that do not have any attributes
filled in.

修改views/posts/_form.html.erb来显示标签的partial：
We will modify +views/posts/_form.html.erb+ to render a partial to make a tag:

<erb>
<% @post.tags.build %>
<%= form_for(@post) do |post_form| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= post_form.label :name %><br />
    <%= post_form.text_field :name %>
  </div>
  <div class="field">
    <%= post_form.label :title %><br />
    <%= post_form.text_field :title %>
  </div>
  <div class="field">
    <%= post_form.label :content %><br />
    <%= post_form.text_area :content %>
  </div>
  <h2>Tags</h2>
  <%= render :partial => 'tags/form',
             :locals => {:form => post_form} %>
  <div class="actions">
    <%= post_form.submit %>
  </div>
<% end %>
</erb>

注意到为了接下来程式码的可读性，我们修改了form_for(@post) do |f|的f变成post_form。
Note that we have changed the +f+ in +form_for(@post) do |f|+ to +post_form+ to
make it easier to understand what is going on.

这个范例也展示了render helper可以接受locals参数来传递区域变数。在这个例子中，partial里面的区域变数form指的就是post_form物件。
This example shows another option of the render helper, being able to pass in
local variables, in this case, we want the local variable +form+ in the partial
to refer to the +post_form+ object.

我们也在表单上方新增一行@post.tags.build，这会确保有空的标签物件可以被使用者编辑，不然的话标签表单没办法显示。
We also add a <tt>@post.tags.build</tt> at the top of this form. This is to make
sure there is a new tag ready to have its name filled in by the user. If you do
not build the new tag, then the form will not appear as there is no new Tag
object ready to create.

建立app/views/tags目录，以及_form.html.erb档案，其内容是标签的表单：
Now create the folder <tt>app/views/tags</tt> and make a file in there called
<tt>_form.html.erb</tt> which contains the form for the tag:

<erb>
<%= form.fields_for :tags do |tag_form| %>
  <div class="field">
    <%= tag_form.label :name, 'Tag:' %>
    <%= tag_form.text_field :name %>
  </div>
  <% unless tag_form.object.nil? || tag_form.object.new_record? %>
    <div class="field">
      <%= tag_form.label :_destroy, 'Remove:' %>
      <%= tag_form.check_box :_destroy %>
    </div>
  <% end %>
<% end %>
</erb>

最后，我们编辑app/views/posts/show.html.erb样板来显示标签。
Finally, we will edit the <tt>app/views/posts/show.html.erb</tt> template to show our tags.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= @post.tags.map { |t| t.name }.join(", ") %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

透过这些修改，你就可以在同一个view 中同时编辑文章跟标签了。
With these changes in place, you'll find that you can edit a post and its tags
directly on the same view.

不过呢，那个@post.tags.map { |t| t.name }.join(", ")实在有点丑，我们可以把它变成helper函式。
However, that method call <tt>@post.tags.map { |t| t.name }.join(", ")</tt> is
awkward, we could handle this by making a helper method.

h3. View Helpers

View Helpers (辅助函式)放在app/helpers目录下，提供一些可以被重复使用的Views函式。在这个例子，我们希望有个字串函式可以把一群物件中的name属性用逗号串接在一起。因为这用在Post show样板，所以我们把它放在PostsHelper里。
View Helpers live in <tt>app/helpers</tt> and provide small snippets of reusable
code for views. In our case, we want a method that strings a bunch of objects
together using their name attribute and joining them with a comma. As this is
for the Post show template, we put it in the PostsHelper.

打开app/helpers/posts_helper.rb加入以下程式：
Open up <tt>app/helpers/posts_helper.rb</tt> and add the following:

<erb>
module PostsHelper
  def join_tags(post)
    post.tags.map { |t| t.name }.join(", ")
  end
end
</erb>

编辑app/views/posts/show.html.erb 视图如下：
Now you can edit the view in <tt>app/views/posts/show.html.erb</tt> to look like
this:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= join_tags(@post) %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

h3. 接下来？What's Next?

到目前为止，你已经建立了你的第一个Rails 应用，请随意修改实验你的程式。不过请不要埋头苦干，当你需要协助的时候，请问问看以下资源：
Now that you've seen your first Rails application, you should feel free to
update it and experiment on your own. But you don't have to do everything
without help. As you need assistance getting up and running with Rails, feel
free to consult these support resources:

* The "Ruby on Rails guides":index.html
* The "Ruby on Rails Tutorial":http://railstutorial.org/book
* The "Ruby on Rails mailing list":http://groups.google.com/group/rubyonrails-talk
* The "#rubyonrails":irc://irc.freenode.net/#rubyonrails channel on irc.freenode.net
* The "Rails Wiki":http://wiki.rubyonrails.org/

你也可以透过Rails 内建的工具来产生文件：
Rails also comes with built-in help that you can generate using the rake command-line utility:

* 执行rake doc:guides会产生一份完整的Rails指南在你的应用程式doc/guides目录下。用浏览器打开doc/guides/index.html就可以了。
Running +rake doc:guides+ will put a full copy of the Rails Guides in the +doc/guides+ folder of your application. Open +doc/guides/index.html+ in your web browser to explore the Guides.
* 执行rake doc:rails会产生一份API documentation文件在doc/api目录下。请打开doc/api/index.html。
Running +rake doc:rails+ will put a full copy of the API documentation for Rails in the +doc/api+ folder of your application. Open +doc/api/index.html+ in your web browser to explore the API documentation.

h3. 一些设定上的诀窍Configuration Gotchas

最简单的方式就是把所有外部资料都当做UTF-8。如果不是的话，函式库跟Rails会需要转换你的资料变成UTF -8，这可能会发生问题。所以最好的方式还是让所有的外部资料都是UTF-8。
The easiest way to work with Rails is to store all external data as UTF-8. If
you don't, Ruby libraries and Rails will often be able to convert your native
data into UTF-8, but this doesn't always work reliably, so you're better off
ensuring that all external data is UTF-8.

常见的症兆是在你的浏览器中出现了带有问号的小黑钻石，或是“ü”变成"Ã¼"。Rails内部可以自动侦测然后修正。但是，如果你有外部资料不是UTF -8，它还是可能无法自动帮你侦测和修正。
If you have made a mistake in this area, the most common symptom is a black
diamond with a question mark inside appearing in the browser. Another common
symptom is characters like "Ã¼" appearing instead of "ü". Rails takes a number
of internal steps to mitigate common causes of these problems that can be
automatically detected and corrected. However, if you have external data that is
not stored as UTF-8, it can occasionally result in these kinds of issues that
cannot be automatically detected by Rails and corrected.

两种常见的非UTF -8原因：
Two very common sources of data that are not UTF-8:
* 你的文字编辑器：大部分的文字编辑器(例如Textmate)预设会存成UTF-8。如果你的不是，这会导致你在样板中输入的文字(例如é)，在浏览器中会变成带有问号的小黑钻石。同样地，在你的I18N翻译档案也可能发生。大部分预设不是UTF -8的编辑器(例如某些版本的Dreamweaver)可以修改预设值，请改成UTF -8。
Your text editor: Most text editors (such as Textmate), default to saving files as
  UTF-8. If your text editor does not, this can result in special characters that you
  enter in your templates (such as é) to appear as a diamond with a question mark inside
  in the browser. This also applies to your I18N translation files.
  Most editors that do not already default to UTF-8 (such as some versions of
  Dreamweaver) offer a way to change the default to UTF-8. Do so.
* 你的资料库。Rails预设会从资料库出来的资料转成UTF -8。但是，如果你的资料库内部不是UTF -8，那么可能没办法存进所有使用者输入的字元。例如，你的使用者输入俄文、希伯来文或是日文字元，而你的资料库内部使用Latin-1，那输入的资料就会在进资料库时不见。所以可能的话，让资料库也使用UTF -8。
Your database. Rails defaults to converting data from your database into UTF-8 at
  the boundary. However, if your database is not using UTF-8 internally, it may not
  be able to store all characters that your users enter. For instance, if your database
  is using Latin-1 internally, and your user enters a Russian, Hebrew, or Japanese
  character, the data will be lost forever once it enters the database. If possible,
  use UTF-8 as the internal storage of your database.




程式
资料库
软体
设定档
资料 数据
档案 文件
元件
样板
预设
介面
网路
物件 对象
函式
程式码
专案
部落格
视窗
支援 支持
资料 信息
伺服器
客制化
客制
送出 提交
宣告 声明
执行 运行