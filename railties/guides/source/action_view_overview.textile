h2. Action View 概述

在本篇中，你将会学习到：

* Action View是什么，如何在Rails中使用它
* 如何在Rails之外使用Action View
* 如何更好地使用模板, partials, and layouts
* Action View提供了哪些辅助方法，如何编写自己的辅助方法
* 如何使用本地化视图

endprologue.

h3. 什么是 ActionView ？

Action View 和 Action Controller 是 Action Pack 中两个主要的组件。 在 Rails 中， Action Pack 获取 Web 请求，它把工作分为控制器部分 （performing the logic ）和视图部分（渲染模板）。典型地， Action Controller将在必要时参与数据库和performing CRUD actions之间的通讯。Action View然后负责响应。

Action View模板使用嵌入式Ruby编写，在HTML内混入标签。为了避免模板被代码搅乱，一些辅助方法类提供了表单、日期和字符串的常见行为。在你的应用程序程序进化过程中加入新的辅助方法也很容易。

Note: 一些 Action View 的特性和 Active Record 有关，但是这并不是说 Action View 基于 Active Record。 Action View 是一个独立的软件包，可以与任意后端协同使用。

h3. 在 Rails 中使用 Action View

对于每个控制器，都在 <tt>app/views</tt> 目录下有一个关联目录，保存着模板文件，用于产生关联到控制器的视图。这些文件用于显示每个控制器Action结果的视图。

让我们看看，当使用脚手架生成器创建一个新的资源时，Rails都干了些啥：

<shell>
$ rails generate scaffold post
      [...]
      invoke  scaffold_controller
      create    app/controllers/posts_controller.rb
      invoke    erb
      create      app/views/posts
      create      app/views/posts/index.html.erb
      create      app/views/posts/edit.html.erb
      create      app/views/posts/show.html.erb
      create      app/views/posts/new.html.erb
      create      app/views/posts/_form.html.erb
      [...]
</shell>

Rails的视图中有一个命名约定。典型地，视图与关联的控制器Action共享名字，你从上面可以看出来。
例如，the index controller action of the <tt>posts_controller.rb</tt> 会使用 <tt>app/views/posts</tt> 目录中的 <tt>index.html.erb</tt> 视图文件。
发送给客户端的完整 HTML 是由这个 ERB 文件、布局模板包装它、和所有这个视图引用的局部模板共享创作完成的。 本篇后面会讲述这三个组件的更多细节。

h3. 在Rails之外使用Action View

Action View 能和 Action Record 一齐很好地工作，但是它也可以和其它 Ruby 工具协同工作。我们可以通过创建一个小型的 "Rack":http://rack.rubyforge.org/ 应用程序来展示这点，这个应用程序包含了 Action View 的功能。这点会有用，比如你想在Rack应用程序中访问Action View的辅助方法。

 确认安装了 Action Pack 和 Rack gems 后，开始吧：

<shell>
$ gem install actionpack
$ gem install rack
</shell>

现在我们创建了一个简单的 "Hello World" 应用程序，它使用了 Active Support 提供的 +titleize+ 方法。

*hello_world.rb:*

<ruby>
require 'rubygems'
require 'active_support/core_ext/string/inflections'
require 'rack'

def hello_world(env)
  [200, {"Content-Type" => "text/html"}, "hello world".titleize]
end

Rack::Handler::Mongrel.run method(:hello_world), :Port => 4567
</ruby>

We can see this all come together by starting up the application and then visiting +http://localhost:4567/+

<shell>
$ ruby hello_world.rb
</shell>

TODO needs a screenshot? I have one - not sure where to put it.

注意一下 'hello world' 是如何被 +titleize+ 辅助方法转换成 'Hello World' 的。

以同样的方式，Action View 也可以在 "Sinatra":http://www.sinatrarb.com/ 中使用。

确认安装了Action Pack 和 Sinatra gems后，让我们开始吧：

<shell>
$ gem install actionpack
$ gem install sinatra
</shell>

现在，我们在 Sinatra 中创建了相同的 "Hello World" 应用程序。

*hello_world.rb:*

<ruby>
require 'rubygems'
require 'action_view'
require 'sinatra'

get '/' do
  erb 'hello world'.titleize
end
</ruby>

然后，我们可以运行应用程序：

<shell>
$ ruby hello_world.rb
</shell>

程序运行后，你可以访问 +http://localhost:4567/+ ， Sinatra 和 Action View 已经协同工作了。

TODO needs a screenshot? I have one - not sure where to put it.

h3. 模板、局部模板和布局

之前提到过，最终的 HTML 输出是由三种 Rails 元素合作完成的： +模板+ 、 +局部模板视图+ 和 +布局+ 。
下面简要介绍一下它们。

h4. 模板

Action View模板可以使用几种办法编写。 如果模板文件是 <tt>.erb</tt> 后缀， 那里面混合了嵌入式 Ruby 语言（ERB）和 HTML 。如果模板文件是 <tt>.builder</tt> 后缀， then a fresh instance of <tt>Builder::XmlMarkup</tt> library is used.

Rails支持多个模板系统，使用文件扩展名分清该用哪个。例如， an HTML file using the ERB template system will have <tt>.html.erb</tt> as a file extension.

h5. ERB

在 ERB 模板中，Ruby 代码可以包含在 +<% %>+ 和 +<%= %>+ 标签之中。 +<% %>+ 标签用于执行 Ruby 代码，不会返回什么东西，比如判断、循环或者代码块。而当你希望获得输出时，使用 +<%= %>+ 标签。

Consider the following loop for names:

<erb>
<b>Names of all the people</b>
<% @people.each do |person| %>
  Name: <%= person.name %><br/>
<% end %>
</erb>

循环 is setup in regular embedding tags +<% %>+ and the name is written using the output embedding tag +<%= %>+. Note that this is not just a usage suggestion, for Regular output functions like print or puts won't work with ERB templates. 所以这是错误的：

<erb>
<%# WRONG %>
Hi, Mr. <% puts "Frodo" %>
</erb>

To suppress leading and trailing whitespaces, you can use +<%-+ +-%>+ interchangeably with +<%+ and +%>+.

h5. Builder

Builder 模板 are a more programmatic alternative to ERB. They are especially useful for generating XML content. 一个名为 +xml+ 的 XmlMarkup 对象 is automatically made available to templates with a <tt>.builder</tt> extension.

这里有一些基本示例：

<ruby>
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href"=>"http://rubyonrails.org")
xml.target("name"=>"compile", "option"=>"fast")
</ruby>

将产生

<html>
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="http://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
</html>

Any method with a block will be treated as an XML markup tag with nested markup in the block. 例如，以下代码：

<ruby>
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
}
</ruby>

会生成：

<html>
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
</div>
</html>

 Basecamp 实际使用中的一条全长度 RSS 示例：

<ruby>
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"

    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("dc:creator", item.author_name) if item_has_creator?(item)
      end
    end
  end
end
</ruby>

h5. 模板缓存

默认地， Rails 会把每个模板编译成方法，以便渲染它。开发模式下，当你修改一个模板， Rails 会检查文件的修改时间并重新编译。

h4. 局部模板

局部模板 – usually just called "partials" – are another device for breaking the rendering process into more manageable chunks. With a partial, you can move the code for rendering a particular piece of a response to its own file.

h5. 命名局部模板

你可以在视图中使用 +render+ 方法，编译其中的局部模板：

<ruby>
<%= render "menu" %>
</ruby>

这会渲染名为 +_menu.html.erb+ 的文件 at that point within the view is being rendered. Note the leading underscore character: partials are named with a leading underscore to distinguish them from regular views, even though they are referred to without the underscore. This holds true even when you're pulling in a partial from another folder:

<ruby>
<%= render "shared/menu" %>
</ruby>

这段代码 will pull in the partial from +app/views/shared/_menu.html.erb+.

h5. 使用局部模板简化视图

局部模板的一种用法，是把它们看成子程序的等价物：把细节移出视图的一种方法，这样你可以更容易地抓住重点。例如这个视图：

<erb>
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
<% @products.each do |product| %>
  <%= render :partial => "product", :locals => { :product => product } %>
<% end %>

<%= render "shared/footer" %>
</erb>

在这里， +_ad_banner.html.erb+ 和 +_footer.html.erb+ 局部模板会包含应用程序中很多页面需要分享的内容。引用时，你不需要了解这些局部模板中的内容细节。

h5. :as 和 :object 选项

By default <tt>ActionView::Partials::PartialRenderer</tt> has its object in a local variable with the same name as the template. So, given

<erb>
<%= render :partial => "product" %>
</erb>

within product we'll get <tt>@product</tt> in the local variable +product+, as if we had written:

<erb>
<%= render :partial => "product", :locals => { :product  => @product } %>
</erb>

With the <tt>:as</tt> option we can specify a different name for said local variable. For example, if we wanted it to be +item+ instead of product+ we'd do:

<erb>
<%= render :partial => "product", :as => 'item' %>
</erb>

The <tt>:object</tt> option can be used to directly specify which object is rendered into the partial; useful when the template's object is elsewhere, in a different ivar or in a local variable for instance.

例如， instead of:

<erb>
<%= render :partial => "product", :locals => { :product  => @item } %>
</erb>

you'd do:

<erb>
<%= render :partial => "product", :object => @item %>
</erb>

The <tt>:object</tt> and <tt>:as</tt> options can be used together.

h5. Rendering Collections

The example of partial use describes a familiar pattern where a template needs to iterate over an array and render a sub template for each of the elements. This pattern has been implemented as a single method that accepts an array and renders a partial by the same name as the elements contained within.
So the three-lined example for rendering all the products can be rewritten with a single line:

<erb>
<%= render :partial => "product", :collection => @products %>
</erb>

When a partial is called with a pluralized collection, then the individual instances of the partial have access to the member of the collection being rendered via a variable named after the partial. In this case, the partial is +_product+ , and within the +_product+ partial, you can refer to +product+ to get the instance that is being rendered.

You can use a shorthand syntax for rendering collections. Assuming @products is a collection of +Product+ instances, you can simply write the following to produce the same result:

<erb>
<%= render @products %>
</erb>

Rails determines the name of the partial to use by looking at the model name in the collection. In fact, you can even create a heterogeneous collection and render it this way, and Rails will choose the proper partial for each member of the collection.

h5. Spacer Templates

You can also specify a second partial to be rendered between instances of the main partial by using the +:spacer_template+ option:

<erb>
<%= render @products, :spacer_template => "product_ruler" %>
</erb>

Rails will render the +_product_ruler+ partial (with no data passed in to it) between each pair of +_product+ partials.

h4. Layouts

TODO...

h3. 按“ Rails 的方式”使用模板、局部视图和布局

TODO...

h3. 局部布局

Partials can have their own layouts applied to them. These layouts are different than the ones that are specified globally for the entire action, but they work in a similar fashion.

Let's say we're displaying a post on a page where it should be wrapped in a +div+ for display purposes. 首先，我们创建一个新的 +Post+ ：

<ruby>
Post.create(:body => 'Partial Layouts are cool!')
</ruby>

In the +show+ template, we'll render the +post+ partial wrapped in the +box+ layout:

*posts/show.html.erb*

<ruby>
<%= render :partial => 'post', :layout => 'box', :locals => {:post => @post} %>
</ruby>

 +box+ 布局在一个 +div+ 中简单地包装了 +post+ 局部模板：

*posts/_box.html.erb*

<ruby>
<div class='box'>
  <%= yield %>
</div>
</ruby>

The +post+ partial wraps the post's +body+ in a +div+ with the +id+ of the post using the +div_for+ helper:

*posts/_post.html.erb*

<ruby>
<%= div_for(post) do %>
  <p><%= post.body %></p>
<% end %>
</ruby>

这个例子将输出：

<html>
<div class='box'>
  <div id='post_1'>
    <p>Partial Layouts are cool!</p>
  </div>
</div>
</html>

Note that the partial layout has access to the local +post+ variable that was passed into the +render+ call. 然而，不象应用级的而已，局部布局还是带有下划线的前缀。

You can also render a block of code within a partial layout instead of calling +yield+. 例如，如果我们没有 +post+ partial, 我们可以这样代替：

*posts/show.html.erb*

<ruby>
<% render(:layout => 'box', :locals => {:post => @post}) do %>
  <%= div_for(post) do %>
    <p><%= post.body %></p>
  <% end %>
<% end %>
</ruby>

If we're using the same +box+ partial from above, his would produce the same output as the previous example.

h3. 视图路径

TODO...

h3. Action View 提供的所有辅助方法概述

以下只是一个简要的 overview summary of the helpers available in Action View. 推荐你查看 API 文档，它涵盖了所有辅助方法的细节，但是这里提供了一个很好的入口。

h4. ActiveRecordHelper

The Active Record Helper makes it easier to create forms for records kept in instance variables. You may also want to review the "Rails Form helpers guide":form_helpers.html.

h5. error_message_on

Returns a string containing the error message attached to the method on the object if one exists.

<ruby>
error_message_on "post", "title"
</ruby>

h5. error_messages_for

Returns a string with a DIV containing all of the error messages for the objects located as instance variables by the names given.

<ruby>
error_messages_for "post"
</ruby>

h5. 表单

Returns a form with inputs for all attributes of the specified Active Record object. For example, let's say we have a +@post+ with attributes named +title+ of type +String+ and +body+ of type +Text+. Calling +form+ would produce a form to creating a new post with inputs for those attributes.

<ruby>
form("post")
</ruby>

<html>
<form action='/posts/create' method='post'>
  <p>
    <label for="post_title">Title</label><br />
    <input id="post_title" name="post[title]" size="30" type="text" value="Hello World" />
  </p>
  <p>
    <label for="post_body">Body</label><br />
    <textarea cols="40" id="post_body" name="post[body]" rows="20"></textarea>
  </p>
  <input name="commit" type="submit" value="Create" />
</form>
</html>

Typically, +form_for+ is used instead of +form+ because it doesn't automatically include all of the model's attributes.

h5. 输入

Returns a default input tag for the type of object returned by the method.

例如， if +@post+ has an attribute +title+ mapped to a +String+ column that holds "Hello World":

<ruby>
input("post", "title") # =>
  <input id="post_title" name="post[title]" size="30" type="text" value="Hello World" />
</ruby>

h4. RecordTagHelper

This module provides methods for generating a container tag, such as a +<div>+, for your record. This is the recommended way of creating a container for render your Active Record object, as it adds an appropriate class and id attributes to that container. You can then refer to those containers easily by following the convention, instead of having to think about which class or id attribute you should use.

h5. content_tag_for

Renders a container tag that relates to your Active Record Object.

For example, given +@post+ is the object of +Post+ class, you can do:

<ruby>
<%= content_tag_for(:tr, @post) do %>
  <td><%= @post.title %></td>
<% end %>
</ruby>

This will generate this HTML output:

<html>
<tr id="post_1234" class="post">
  <td>Hello World!</td>
</tr>
</html>

You can also supply HTML attributes as an additional option hash. 例如：

<ruby>
<%= content_tag_for(:tr, @post, :class => "frontpage") do %>
  <td><%= @post.title %></td>
<% end %>
</ruby>

会生成：

<html>
<tr id="post_1234" class="post frontpage">
  <td>Hello World!</td>
</tr>
</html>

You can pass a collection of Active Record objects. This method will loop through your objects and create a container for each of them. For example, given +@posts+ is an array of two +Post+ objects:

<ruby>
<%= content_tag_for(:tr, @posts) do |post| %>
  <td><%= post.title %></td>
<% end %>
</ruby>

Will generate this HTML output:

<html>
<tr id="post_1234" class="post">
  <td>Hello World!</td>
</tr>
<tr id="post_1235" class="post">
  <td>Ruby on Rails Rocks!</td>
</tr>
</html>

h5. div_for

This is actually a convenient method which calls +content_tag_for+ internally with +:div+ as the tag name. You can pass either an Active Record object or a collection of objects. For example:

<ruby>
<%= div_for(@post, :class => "frontpage") do %>
  <td><%= @post.title %></td>
<% end %>
</ruby>

Will generate this HTML output:

<html>
<div id="post_1234" class="post frontpage">
  <td>Hello World!</td>
</div>
</html>

h4. AssetTagHelper

This module provides methods for generating HTML that links views to assets such as images, JavaScript files, stylesheets, and feeds.

By default, Rails links to these assets on the current host in the public folder, but you can direct Rails to link to assets from a dedicated assets server by setting +ActionController::Base.asset_host+ in the application configuration, typically in +config/environments/production.rb+. For example, let's say your asset host is +assets.example.com+:

<ruby>
ActionController::Base.asset_host = "assets.example.com"
image_tag("rails.png") # => <img src="http://assets.example.com/images/rails.png" alt="Rails" />
</ruby>

h5. register_javascript_expansion

Register one or more JavaScript files to be included when symbol is passed to javascript_include_tag. This method is typically intended to be called from plugin initialization to register JavaScript files that the plugin installed in +public/javascripts+.

<ruby>
ActionView::Helpers::AssetTagHelper.register_javascript_expansion :monkey => ["head", "body", "tail"]

javascript_include_tag :monkey # =>
  <script type="text/javascript" src="/javascripts/head.js"></script>
  <script type="text/javascript" src="/javascripts/body.js"></script>
  <script type="text/javascript" src="/javascripts/tail.js"></script>
</ruby>

h5. register_stylesheet_expansion

Register one or more stylesheet files to be included when symbol is passed to +stylesheet_link_tag+. This method is typically intended to be called from plugin initialization to register stylesheet files that the plugin installed in +public/stylesheets+.

<ruby>
ActionView::Helpers::AssetTagHelper.register_stylesheet_expansion :monkey => ["head", "body", "tail"]

stylesheet_link_tag :monkey # =>
  <link href="/stylesheets/head.css" media="screen" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/body.css" media="screen" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/tail.css" media="screen" rel="stylesheet" type="text/css" />
</ruby>

h5. auto_discovery_link_tag

Returns a link tag that browsers and news readers can use to auto-detect an RSS or ATOM feed.

<ruby>
auto_discovery_link_tag(:rss, "http://www.example.com/feed.rss", {:title => "RSS Feed"}) # =>
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://www.example.com/feed" />
</ruby>

h5. image_path

Computes the path to an image asset in the +public/images+ directory. Full paths from the document root will be passed through. Used internally by +image_tag+ to build the image path.

<ruby>
image_path("edit.png") # => /images/edit.png
</ruby>

h5. image_tag

Returns an html image tag for the source. The source can be a full path or a file that exists in your +public/images+ directory.

<ruby>
image_tag("icon.png") # => <img src="/images/icon.png" alt="Icon" />
</ruby>

h5. javascript_include_tag

Returns an html script tag for each of the sources provided. You can pass in the filename (+.js+ extension is optional) of JavaScript files that exist in your +public/javascripts+ directory for inclusion into the current page or you can pass the full path relative to your document root.

<ruby>
javascript_include_tag "common" # =>
  <script type="text/javascript" src="/javascripts/common.js"></script>
</ruby>

If the application does not use the asset pipeline, to include the jQuery JavaScript library in your application, pass +:defaults+ as the source. When using +:defaults+, if an +application.js+ file exists in your +public/javascripts+ directory, it will be included as well.

<ruby>
javascript_include_tag :defaults
</ruby>

You can also include all JavaScript files in the +public/javascripts+ directory using +:all+ as the source.

<ruby>
javascript_include_tag :all
</ruby>

You can also cache multiple JavaScript files into one file, which requires less HTTP connections to download and can better be compressed by gzip (leading to faster transfers). Caching will only happen if +ActionController::Base.perform_caching+ is set to true (which is the case by default for the Rails production environment, but not for the development environment).

<ruby>
javascript_include_tag :all, :cache => true # =>
  <script type="text/javascript" src="/javascripts/all.js"></script>
</ruby>

h5. javascript_path

Computes the path to a JavaScript asset in the +public/javascripts+ directory. If the source filename has no extension, +.js+ will be appended. Full paths from the document root will be passed through. Used internally by +javascript_include_tag+ to build the script path.

<ruby>
javascript_path "common" # => /javascripts/common.js
</ruby>

h5. stylesheet_link_tag

Returns a stylesheet link tag for the sources specified as arguments. If you don't specify an extension, +.css+ will be appended automatically.

<ruby>
stylesheet_link_tag "application" # =>
  <link href="/stylesheets/application.css" media="screen" rel="stylesheet" type="text/css" />
</ruby>

You can also include all styles in the stylesheet directory using :all as the source:

<ruby>
stylesheet_link_tag :all
</ruby>

You can also cache multiple stylesheets into one file, which requires less HTTP connections and can better be compressed by gzip (leading to faster transfers). Caching will only happen if ActionController::Base.perform_caching is set to true (which is the case by default for the Rails production environment, but not for the development environment).

<ruby>
stylesheet_link_tag :all, :cache => true
  <link href="/stylesheets/all.css"  media="screen" rel="stylesheet" type="text/css" />
</ruby>

h5. stylesheet_path

Computes the path to a stylesheet asset in the +public/stylesheets+ directory. If the source filename has no extension, .css will be appended. Full paths from the document root will be passed through. Used internally by stylesheet_link_tag to build the stylesheet path.

<ruby>
stylesheet_path "application" # => /stylesheets/application.css
</ruby>

h4. AtomFeedHelper

h5. atom_feed

This helper makes building an ATOM feed easy. Here's a full usage example:

*config/routes.rb*

<ruby>
resources :posts
</ruby>

*app/controllers/posts_controller.rb*

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html
    format.atom
  end
end
</ruby>

*app/views/posts/index.atom.builder*

<ruby>
atom_feed do |feed|
  feed.title("Posts Index")
  feed.updated((@posts.first.created_at))

  @posts.each do |post|
    feed.entry(post) do |entry|
      entry.title(post.title)
      entry.content(post.body, :type => 'html')

      entry.author do |author|
        author.name(post.author_name)
      end
    end
  end
end
</ruby>

h4. BenchmarkHelper

h5. benchmark

Allows you to measure the execution time of a block in a template and records the result to the log. Wrap this block around expensive operations or possible bottlenecks to get a time reading for the operation.

<ruby>
<% benchmark "Process data files" do %>
  <%= expensive_files_operation %>
<% end %>
</ruby>

This would add something like "Process data files (0.34523)" to the log, which you can then use to compare timings when optimizing your code.

h4. CacheHelper

h5. cache

A method for caching fragments of a view rather than an entire action or page. This technique is useful caching pieces like menus, lists of news topics, static HTML fragments, and so on. This method takes a block that contains the content you wish to cache. See +ActionController::Caching::Fragments+ for more information.

<ruby>
<% cache do %>
  <%= render "shared/footer" %>
<% end %>
</ruby>

h4. CaptureHelper

h5. capture

The +capture+ method allows you to extract part of a template into a variable. You can then use this variable anywhere in your templates or layout.

<ruby>
<% @greeting = capture do %>
  <p>Welcome! The date and time is <%= Time.now %></p>
<% end %>
</ruby>

The captured variable can then be used anywhere else.

<ruby>
<html>
  <head>
    <title>Welcome!</title>
  </head>
  <body>
    <%= @greeting %>
  </body>
</html>
</ruby>

h5. content_for

Calling +content_for+ stores a block of markup in an identifier for later use. You can make subsequent calls to the stored content in other templates or the layout by passing the identifier as an argument to +yield+.

For example, let's say we have a standard application layout, but also a special page that requires certain Javascript that the rest of the site doesn't need. We can use +content_for+ to include this Javascript on our special page without fattening up the rest of the site.

*app/views/layouts/application.html.erb*

<ruby>
<html>
  <head>
    <title>Welcome!</title>
    <%= yield :special_script %>
  </head>
  <body>
    <p>Welcome! The date and time is <%= Time.now %></p>
  </body>
</html>
</ruby>

*app/views/posts/special.html.erb*

<ruby>
<p>This is a special page.</p>

<% content_for :special_script do %>
  <script type="text/javascript">alert('Hello!')</script>
<% end %>
</ruby>

h4. DateHelper

h5. date_select

Returns a set of select tags (one for year, month, and day) pre-selected for accessing a specified date-based attribute.

<ruby>
date_select("post", "published_on")
</ruby>

h5. datetime_select

Returns a set of select tags (one for year, month, day, hour, and minute) pre-selected for accessing a specified datetime-based attribute.

<ruby>
datetime_select("post", "published_on")
</ruby>

h5. distance_of_time_in_words

Reports the approximate distance in time between two Time or Date objects or integers as seconds. Set +include_seconds+ to true if you want more detailed approximations.

<ruby>
distance_of_time_in_words(Time.now, Time.now + 15.seconds)        # => less than a minute
distance_of_time_in_words(Time.now, Time.now + 15.seconds, true)  # => less than 20 seconds
</ruby>

h5. select_date

Returns a set of html select-tags (one for year, month, and day) pre-selected with the +date+ provided.

<ruby>
# Generates a date select that defaults to the date provided (six days after today)
select_date(Time.today + 6.days)

# Generates a date select that defaults to today (no specified date)
select_date()
</ruby>

h5. select_datetime

Returns a set of html select-tags (one for year, month, day, hour, and minute) pre-selected with the +datetime+ provided.

<ruby>
# Generates a datetime select that defaults to the datetime provided (four days after today)
select_datetime(Time.now + 4.days)

# Generates a datetime select that defaults to today (no specified datetime)
select_datetime()
</ruby>

h5. select_day

Returns a select tag with options for each of the days 1 through 31 with the current day selected.

<ruby>
# Generates a select field for days that defaults to the day for the date provided
select_day(Time.today + 2.days)

# Generates a select field for days that defaults to the number given
select_day(5)
</ruby>

h5. select_hour

Returns a select tag with options for each of the hours 0 through 23 with the current hour selected.

<ruby>
# Generates a select field for minutes that defaults to the minutes for the time provided
select_minute(Time.now + 6.hours)
</ruby>

h5. select_minute

Returns a select tag with options for each of the minutes 0 through 59 with the current minute selected.

<ruby>
# Generates a select field for minutes that defaults to the minutes for the time provided.
select_minute(Time.now + 6.hours)
</ruby>

h5. select_month

Returns a select tag with options for each of the months January through December with the current month selected.

<ruby>
# Generates a select field for months that defaults to the current month
select_month(Date.today)
</ruby>

h5. select_second

Returns a select tag with options for each of the seconds 0 through 59 with the current second selected.

<ruby>
# Generates a select field for seconds that defaults to the seconds for the time provided
select_second(Time.now + 16.minutes)
</ruby>

h5. select_time

Returns a set of html select-tags (one for hour and minute).

<ruby>
# Generates a time select that defaults to the time provided
select_time(Time.now)
</ruby>

h5. select_year

Returns a select tag with options for each of the five years on each side of the current, which is selected. The five year radius can be changed using the +:start_year+ and +:end_year+ keys in the +options+.

<ruby>
# Generates a select field for five years on either side of Date.today that defaults to the current year
select_year(Date.today)

# Generates a select field from 1900 to 2009 that defaults to the current year
select_year(Date.today, :start_year => 1900, :end_year => 2009)
</ruby>

h5. time_ago_in_words

Like +distance_of_time_in_words+, but where +to_time+ is fixed to +Time.now+.

<ruby>
time_ago_in_words(3.minutes.from_now)       # => 3 minutes
</ruby>

h5. time_select

Returns a set of select tags (one for hour, minute and optionally second) pre-selected for accessing a specified time-based attribute. The selects are prepared for multi-parameter assignment to an Active Record object.

<ruby>
# Creates a time select tag that, when POSTed, will be stored in the order variable in the submitted attribute
time_select("order", "submitted")
</ruby>

h4. DebugHelper

Returns a +pre+ tag that has object dumped by YAML. This creates a very readable way to inspect an object.

<ruby>
my_hash = {'first' => 1, 'second' => 'two', 'third' => [1,2,3]}
debug(my_hash)
</ruby>

<html>
<pre class='debug_dump'>---
first: 1
second: two
third:
- 1
- 2
- 3
</pre>
</html>

h4. FormHelper

表单辅助方法设计用于 make working with models much easier compared to using just standard HTML elements by providing a set of methods for creating forms based on your models. This helper generates the HTML for forms, providing a method for each sort of input (e.g., text, password, select, and so on). When the form is submitted (i.e., when the user hits the submit button or form.submit is called via JavaScript), the form inputs will be bundled into the params object and passed back to the controller.

There are two types of form helpers: those that specifically work with model attributes and those that don't. This helper deals with those that work with model attributes; to see an example of form helpers that don't work with model attributes, check the ActionView::Helpers::FormTagHelper documentation.

The core method of this helper, form_for, gives you the ability to create a form for a model instance; for example, let's say that you have a model Person and want to create a new instance of it:

<ruby>
# Note: a @person variable will have been created in the controller (e.g. @person = Person.new)
<%= form_for @person, :url => { :action => "create" } do |f| %>
  <%= f.text_field :first_name %>
  <%= f.text_field :last_name %>
  <%= submit_tag 'Create' %>
<% end %>
</ruby>

生成的 HTML 会这样：

<html>
<form action="/persons/create" method="post">
  <input id="person_first_name" name="person[first_name]" size="30" type="text" />
  <input id="person_last_name" name="person[last_name]" size="30" type="text" />
  <input name="commit" type="submit" value="Create" />
</form>
</html>

The params object created when this form is submitted would look like:

<ruby>
{"action"=>"create", "controller"=>"persons", "person"=>{"first_name"=>"William", "last_name"=>"Smith"}}
</ruby>

The params hash has a nested person value, which can therefore be accessed with params[:person] in the controller.

h5. check_box

Returns a checkbox tag tailored for accessing a specified attribute.

<ruby>
# Let's say that @post.validated? is 1:
check_box("post", "validated")
# => <input type="checkbox" id="post_validated" name="post[validated]" value="1" />
#    <input name="post[validated]" type="hidden" value="0" />
</ruby>

h5. fields_for

Creates a scope around a specific model object like form_for, but doesn't create the form tags themselves. This makes fields_for suitable for specifying additional model objects in the same form:

<ruby>
<%= form_for @person, :url => { :action => "update" } do |person_form| %>
  First name: <%= person_form.text_field :first_name %>
  Last name : <%= person_form.text_field :last_name %>

  <%= fields_for @person.permission do |permission_fields| %>
    Admin?  : <%= permission_fields.check_box :admin %>
  <% end %>
<% end %>
</ruby>

h5. file_field

Returns a file upload input tag tailored for accessing a specified attribute.

<ruby>
file_field(:user, :avatar)
# => <input type="file" id="user_avatar" name="user[avatar]" />
</ruby>

h5. form_for

Creates a form and a scope around a specific model object that is used as a base for questioning about values for the fields.

<ruby>
<%= form_for @post do |f| %>
  <%= f.label :title, 'Title' %>:
  <%= f.text_field :title %><br />
  <%= f.label :body, 'Body' %>:
  <%= f.text_area :body %><br />
<% end %>
</ruby>

h5. hidden_field

Returns a hidden input tag tailored for accessing a specified attribute.

<ruby>
hidden_field(:user, :token)
# => <input type="hidden" id="user_token" name="user[token]" value="#{@user.token}" />
</ruby>

h5. label

Returns a label tag tailored for labelling an input field for a specified attribute.

<ruby>
label(:post, :title)
# => <label for="post_title">Title</label>
</ruby>

h5. password_field

Returns an input tag of the "password" type tailored for accessing a specified attribute.

<ruby>
password_field(:login, :pass)
# => <input type="text" id="login_pass" name="login[pass]" value="#{@login.pass}" />
</ruby>

h5. radio_button

Returns a radio button tag for accessing a specified attribute.

<ruby>
# Let's say that @post.category returns "rails":
radio_button("post", "category", "rails")
radio_button("post", "category", "java")
# => <input type="radio" id="post_category_rails" name="post[category]" value="rails" checked="checked" />
#    <input type="radio" id="post_category_java" name="post[category]" value="java" />
</ruby>

h5. text_area

Returns a textarea opening and closing tag set tailored for accessing a specified attribute.

<ruby>
text_area(:comment, :text, :size => "20x30")
# => <textarea cols="20" rows="30" id="comment_text" name="comment[text]">
#      #{@comment.text}
#    </textarea>
</ruby>

h5. text_field

Returns an input tag of the "text" type tailored for accessing a specified attribute.

<ruby>
text_field(:post, :title)
# => <input type="text" id="post_title" name="post[title]" value="#{@post.title}" />
</ruby>

h4. FormOptionsHelper

Provides a number of methods for turning different kinds of containers into a set of option tags.

h5. collection_select

Returns +select+ and +option+ tags for the collection of existing return values of +method+ for +object+'s class.

Example object structure for use with this method:

<ruby>
class Post < ActiveRecord::Base
  belongs_to :author
end

class Author < ActiveRecord::Base
  has_many :posts
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
</ruby>

Sample usage (selecting the associated Author for an instance of Post, +@post+):

<ruby>
collection_select(:post, :author_id, Author.all, :id, :name_with_initial, {:prompt => true})
</ruby>

If <tt>@post.author_id</tt> is 1, this would return:

<html>
<select name="post[author_id]">
  <option value="">Please select</option>
  <option value="1" selected="selected">D. Heinemeier Hansson</option>
  <option value="2">D. Thomas</option>
  <option value="3">M. Clark</option>
</select>
</html>

h5. country_options_for_select

Returns a string of option tags for pretty much any country in the world.

h5. country_select

Return select and option tags for the given object and method, using country_options_for_select to generate the list of option tags.

h5. option_groups_from_collection_for_select

Returns a string of +option+ tags, like +options_from_collection_for_select+, but groups them by +optgroup+ tags based on the object relationships of the arguments.

Example object structure for use with this method:

<ruby>
class Continent < ActiveRecord::Base
  has_many :countries
  # attribs: id, name
end

class Country < ActiveRecord::Base
  belongs_to :continent
  # attribs: id, name, continent_id
end
</ruby>

Sample usage:

<ruby>
option_groups_from_collection_for_select(@continents, :countries, :name, :id, :name, 3)
</ruby>

Possible output:

<html>
<optgroup label="Africa">
  <option value="1">Egypt</option>
  <option value="4">Rwanda</option>
  ...
</optgroup>
<optgroup label="Asia">
  <option value="3" selected="selected">China</option>
  <option value="12">India</option>
  <option value="5">Japan</option>
  ...
</optgroup>
</html>

Note: Only the +optgroup+ and +option+ tags are returned, so you still have to wrap the output in an appropriate +select+ tag.

h5. options_for_select

Accepts a container (hash, array, enumerable, your type) and returns a string of option tags.

<ruby>
options_for_select([ "VISA", "MasterCard" ])
# => <option>VISA</option> <option>MasterCard</option>
</ruby>

Note: Only the +option+ tags are returned, you have to wrap this call in a regular HTML +select+ tag.

h5. options_from_collection_for_select

Returns a string of option tags that have been compiled by iterating over the +collection+ and assigning the result of a call to the +value_method+ as the option value and the +text_method+ as the option text.

<ruby>
# options_from_collection_for_select(collection, value_method, text_method, selected = nil)
</ruby>

For example, imagine a loop iterating over each person in @project.people to generate an input tag:

<ruby>
options_from_collection_for_select(@project.people, "id", "name")
# => <option value="#{person.id}">#{person.name}</option>
</ruby>

Note: Only the +option+ tags are returned, you have to wrap this call in a regular HTML +select+ tag.

h5. select

Create a select tag and a series of contained option tags for the provided object and method.

Example:

<ruby>
select("post", "person_id", Person.all.collect {|p| [ p.name, p.id ] }, { :include_blank => true })
</ruby>

If <tt>@post.person_id</tt> is 1, this would become:

<html>
<select name="post[person_id]">
  <option value=""></option>
  <option value="1" selected="selected">David</option>
  <option value="2">Sam</option>
  <option value="3">Tobias</option>
</select>
</html>

h5. time_zone_options_for_select

Returns a string of option tags for pretty much any time zone in the world.

h5. time_zone_select

Return select and option tags for the given object and method, using +time_zone_options_for_select+ to generate the list of option tags.

<ruby>
time_zone_select( "user", "time_zone")
</ruby>

h4. FormTagHelper

Provides a number of methods for creating form tags that doesn't rely on an Active Record object assigned to the template like FormHelper does. Instead, you provide the names and values manually.

h5. check_box_tag

Creates a check box form input tag.

<ruby>
check_box_tag 'accept'
# => <input id="accept" name="accept" type="checkbox" value="1" />
</ruby>

h5. field_set_tag

Creates a field set for grouping HTML form elements.

<ruby>
<%= field_set_tag do %>
  <p><%= text_field_tag 'name' %></p>
<% end %>
# => <fieldset><p><input id="name" name="name" type="text" /></p></fieldset>
</ruby>

h5. file_field_tag

Creates a file upload field.

Prior to Rails 3.1, if you are using file uploads, then you will need to set the multipart option for the form tag. Rails 3.1+ does this automatically.

<ruby>
<%= form_tag { :action => "post" }, { :multipart => true } do %>
  <label for="file">File to Upload</label> <%= file_field_tag "file" %>
  <%= submit_tag %>
<% end %>
</ruby>

Example output:

<ruby>
file_field_tag 'attachment'
# => <input id="attachment" name="attachment" type="file" />
</ruby>

h5. form_tag

Starts a form tag that points the action to an url configured with +url_for_options+ just like +ActionController::Base#url_for+.

<ruby>
<%= form_tag '/posts' do %>
  <div><%= submit_tag 'Save' %></div>
<% end %>
# => <form action="/posts" method="post"><div><input type="submit" name="submit" value="Save" /></div></form>
</ruby>

h5. hidden_field_tag

Creates a hidden form input field used to transmit data that would be lost due to HTTP's statelessness or data that should be hidden from the user.

<ruby>
hidden_field_tag 'token', 'VUBJKB23UIVI1UU1VOBVI@'
# => <input id="token" name="token" type="hidden" value="VUBJKB23UIVI1UU1VOBVI@" />
</ruby>

h5. image_submit_tag

Displays an image which when clicked will submit the form.

<ruby>
image_submit_tag("login.png")
# => <input src="/images/login.png" type="image" />
</ruby>

h5. label_tag

Creates a label field.

<ruby>
label_tag 'name'
# => <label for="name">Name</label>
</ruby>

h5. password_field_tag

Creates a password field, a masked text field that will hide the users input behind a mask character.

<ruby>
password_field_tag 'pass'
# => <input id="pass" name="pass" type="password" />
</ruby>

h5. radio_button_tag

Creates a radio button; use groups of radio buttons named the same to allow users to select from a group of options.

<ruby>
radio_button_tag 'gender', 'male'
# => <input id="gender_male" name="gender" type="radio" value="male" />
</ruby>

h5. select_tag

Creates a dropdown selection box.

<ruby>
select_tag "people", "<option>David</option>"
# => <select id="people" name="people"><option>David</option></select>
</ruby>

h5. submit_tag

Creates a submit button with the text provided as the caption.

<ruby>
submit_tag "Publish this post"
# => <input name="commit" type="submit" value="Publish this post" />
</ruby>

h5. text_area_tag

Creates a text input area; use a textarea for longer text inputs such as blog posts or descriptions.

<ruby>
text_area_tag 'post'
# => <textarea id="post" name="post"></textarea>
</ruby>

h5. text_field_tag

Creates a standard text field; use these text fields to input smaller chunks of text like a username or a search query.

<ruby>
text_field_tag 'name'
# => <input id="name" name="name" type="text" />
</ruby>

h4. JavaScriptHelper

Provides functionality for working with JavaScript in your views.

h5. button_to_function

Returns a button that'll trigger a JavaScript function using the onclick handler. Examples:

<ruby>
button_to_function "Greeting", "alert('Hello world!')"
button_to_function "Delete", "if (confirm('Really?')) do_delete()"
button_to_function "Details" do |page|
  page[:details].visual_effect :toggle_slide
end
</ruby>

h5. define_javascript_functions

Includes the Action Pack JavaScript libraries inside a single +script+ tag.

h5. escape_javascript

Escape carrier returns and single and double quotes for JavaScript segments.

h5. javascript_tag

Returns a JavaScript tag wrapping the provided code.

<ruby>
javascript_tag "alert('All is good')"
</ruby>

<html>
<script type="text/javascript">
//<![CDATA[
alert('All is good')
//]]>
</script>
</html>

h5. link_to_function

Returns a link that will trigger a JavaScript function using the onclick handler and return false after the fact.

<ruby>
link_to_function "Greeting", "alert('Hello world!')"
# => <a onclick="alert('Hello world!'); return false;" href="#">Greeting</a>
</ruby>

h4. NumberHelper

将数字转换成格式化的字符串。Methods are provided for phone numbers, currency, percentage, precision, positional notation, and file size.

h5. number_to_currency

Formats a number into a currency string (e.g., $13.65).

<ruby>
number_to_currency(1234567890.50) # => $1,234,567,890.50
</ruby>

h5. number_to_human_size

Formats the bytes in size into a more understandable representation; useful for reporting file sizes to users.

<ruby>
number_to_human_size(1234)          # => 1.2 KB
number_to_human_size(1234567)       # => 1.2 MB
</ruby>

h5. number_to_percentage

Formats a number as a percentage string.

<ruby>
number_to_percentage(100, :precision => 0)        # => 100%
</ruby>

h5. number_to_phone

将数字格式成为美国电话号码格式。

<ruby>
number_to_phone(1235551234) # => 123-555-1234
</ruby>

h5. number_with_delimiter

把数字加入千分位逗号。

<ruby>
number_with_delimiter(12345678) # => 12,345,678
</ruby>

h5. number_with_precision

Formats a number with the specified level of +precision+, 默认为 3 位。

<ruby>
number_with_precision(111.2345)     # => 111.235
number_with_precision(111.2345, 2)  # => 111.23
</ruby>

h3. 本地化视图

Action View可以根据当前的区域渲染不同的模板。

例如， suppose you have a Posts controller with a show action. 调用这个Action默认会渲染 +app/views/posts/show.html.erb+ 。但是如果你设置了 +I18n.locale = :de+ ，那么会渲染 +app/views/posts/show.de.html.erb+ 。 如果本地化模板不存在，the undecorated version will be used. 这意味着你不需要为所有的情况提供本地化视图， but they will be preferred and used if available.

你可以使用同样的技术来本地化公共文件夹中的 rescue files 。 例如，设置 +I18n.locale = :de+ 并创建了 +public/500.de.html+ 和 +public/404.de.html+ ，会让你拥有本地化的 rescue 页面。

Since Rails doesn't restrict the symbols that you use to set I18n.locale, you can leverage this system to display different content depending on anything you like. For example, suppose you have some "expert" users that should see different pages from "normal" users. You could add the following to +app/controllers/application.rb+:

<ruby>
before_filter :set_expert_locale

def set_expert_locale
  I18n.locale = :expert if current_user.expert?
end
</ruby>

Then you could create special views like +app/views/posts/show.expert.html.erb+ that would only be displayed to 高级用户。

你可以在 "这里":i18n.html 阅读到更多的 Rails 国际化API。
